{"meta":{"title":"LucunJi","subtitle":null,"description":null,"author":"LucunJi","url":"http://lucunji.github.io"},"pages":[{"title":"Booklist","date":"2018-12-12T23:39:00.000Z","updated":"2019-12-22T10:04:54.035Z","comments":true,"path":"booklist/index.html","permalink":"http://lucunji.github.io/booklist/index.html","excerpt":"","text":"⚠ 施=====工=====中 ⚠ ►虽然魔茶那边已经有了个大书库，但我还是在这里做一些分享，希望能帮助更多的人。"},{"title":"Gallery","date":"2018-12-13T00:12:26.000Z","updated":"2018-12-21T02:43:11.783Z","comments":true,"path":"gallery/index.html","permalink":"http://lucunji.github.io/gallery/index.html","excerpt":"","text":"⚠ 施=====工=====中 ⚠"},{"title":"All Tags","date":"2018-12-12T20:39:03.000Z","updated":"2018-12-21T02:42:46.657Z","comments":false,"path":"tags/index.html","permalink":"http://lucunji.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Noita 施法机制分析","slug":"noita-casting-mechanics","date":"2020-09-13T02:24:55.000Z","updated":"2020-09-14T00:18:24.496Z","comments":true,"path":"2020/09/12/noita-casting-mechanics/","link":"","permalink":"http://lucunji.github.io/2020/09/12/noita-casting-mechanics/","excerpt":"类似编程语言的法术编排是 Noita 中的一大亮点，也是一大难点。《如何在&lt;Noita&gt;中打造爆款法术》（或曰《&lt;Noita&gt;法术编程指南》）一文较完整地讨论了法术编排和释放的机制，但依然存在不少失误。本文尝试在此基础上进行进一步的假设和实验，力图提出一个更加普适、更加易于理解和分析的理论，为 Noita 的游玩提供帮助。","text":"类似编程语言的法术编排是 Noita 中的一大亮点，也是一大难点。《如何在&lt;Noita&gt;中打造爆款法术》（或曰《&lt;Noita&gt;法术编程指南》）一文较完整地讨论了法术编排和释放的机制，但依然存在不少失误。本文尝试在此基础上进行进一步的假设和实验，力图提出一个更加普适、更加易于理解和分析的理论，为 Noita 的游玩提供帮助。 ►讨论范围 本文将着重讨论以下几类法术： 投射物（projectile）：既包括从法杖中飞出后拥有初速度的法术，即火花弹、炸弹、链锯之类一般意义上的投射物；也包括一般情况下不拥有初速度的法术，即粘液雾、静止之环、雷霆爆炸等静态投射物（static projectile）。 投射修正（projectile modifiers）：单独放置于法杖中不提供任何效果，需要和投射物以一定的先后顺序搭配，才能依附投射物产生效果的法术。如伤害增强、火焰轨迹、物质吞噬者、反重力等。 多重施放（multicast）：增加施放数量的法术。可以让一根法杖一次射出更多的投射物，或者人一个带有触发/定时的投射物施放更多的投射物。如x重法术，x重散射法术和阵型。 以下法术不会深入讨论： 被动（passive）：如能量盾、火把等，安装在法杖内无须施法即可在法杖处生效的法术。即使如此，它们依然会被以类似投射修正的方式在法杖内被触发。因此，可将它们视为对法杖起作用的投射修正看待。 实用（utility）：如全知之眼，类似静态投射物，但仅仅在施法的一瞬间提供实用功能。 材料（material）：如点金（Touch of Gold）、酸液之海、水等，类似静态投射物，但仅仅在施法的一瞬间在世界内直接生成/转化物质。 关于魔杖 法杖的施放延迟、充能时间不会讨论。 始终施放的效果是：每次施法时最先施放始终施放的法术，并且不消耗魔力和施放数 另外，本文不会过多解释各种法术的效果和使用时的注意事项、搭配技巧。 ►分析方法的改进 要分析法术的不同编排所产生的效果，首先需要将法杖内的法术分割成有意义、相互关联的部分，从而化整为零，方便理解。 《&lt;Noita&gt;法术编程指南》提出了将法术拆分成层次明显的树状图，并根据一定原则加以分析的思路。 投射修正法术三原则 投射修正法术不修正投射物(包括静态投射物) 以外的其他法术,例如投射修正法术自身、物质法术、被动法术等。 如果投射修正法术是某法术的父法术,那么二者之间有其他触发法术时不产生修正;如果投射修正法术是某法术的子法术,那将不产生修正。 投射修正法术上述情况之外的任何法术。 图中的火焰轨迹应当同时修正能量球和带有触发的火花弹，然而在图中它与火花弹处于两条不同的分支，并且处于能量球的上方，容易让人误以为能量球是火焰轨迹的子法术，火花弹与火焰轨迹不相干，不接受修正。另外，这个法术树可以被搭建成多种完全等效的结构：火焰轨迹在带有触发的火花弹处，而不在能量球一侧；或者干脆将火焰轨迹置于阵型-分叉的上方。 为了减少误导性，简化分析过程，这里提出了一种围绕触发/定时法术展开的，贴合横向编排思路的分段分析方式。 ►施法数的变化 观察如下序列在编辑后的第一次发射效果，可以看到只射出了有“燃烧轨迹”和“伤害立场”的火花弹和能量球体，没有“蛇形”的效果，没有发射魔法箭。 如果按照从左到右的思维去理解，可以认为法杖在“二重散射法术”这里消耗了法杖自带的 1 施放数，并且增加了多重施放的 2 施放数。随后从左到右涉及到燃烧轨迹、火花弹、伤害力场、能量球体。到能量球体处，施放数量被两个投射物法术消耗殆尽，于是后续的蛇形和魔法箭没有涉及到此次施法。 以上是施法数的变化规律。可以看出，投射修正不消耗施法数，其它法术都会消耗 1 施法数，多重施放会在消耗 1 施法数的基础上再增加若干施放数。 ►触发与定时法术 带有触发/定时的投射物法术时，触发/定时法术会携带一部分法术。这些触发/定时法术会独立计算施放数。 在上面的例子中，“带有触发的火花弹”单独对施放数进行计算，从而能够在远处施放伤害力场和能量球体。这个行为使得外部的施放数在进行计算时跳过了伤害力场和能量球体，直接对魔法箭进行计算。 另外，燃烧轨迹只对火花弹和魔法箭有效；伤害力场只对能量球体有效。这时候我们需要对投射修正的作用范围进行考虑。 ►投射修正的范围 当同时考虑多个投射修正、多重施放和带有触发/定时的法术时，情况会稍显复杂。为了探明这一点，我们需要对下面这个序列进行分析： 如果直接进行观察，很可能会误以为燃烧轨迹只对能量球体和火花弹有效。然而在分析后会发现，魔法箭、能量球体和火花弹都会享受燃烧轨迹和伤害力场的投射修正效果。可以说，多重施放只会造成施放数的增减，并不会产生如同定时/触发法术那样的嵌套关系。 并且，由于沉重一击只对带有定时的火花弹有效；燃烧轨迹和伤害力场只对魔法箭、能量球体和火花弹有效。再结合之前的几个例子，可以推断出投射修正对且仅对嵌套关系中同一层的所有法术生效。在 触发与定时法术 段落中的例子里，由于魔法箭和带有触发的火花弹同属于施放数计算的最外层，都会享受到处于同一层的燃烧轨迹。 ►快速分析法 根据之前提到的几个要点，这里归纳总结出一个快速分析法术嵌套关系、投射修正作用范围的方法： 投射修正不消耗施法数，其它法术都消耗 1 施法数，多重施放会在消耗 1 施法数的基础上再增加若干施放数。 定时/触发法术会造成嵌套关系。不同嵌套层的施放数分别计算。 多重施放增加的施放数作用与它所处的嵌套层。 内层的施放数计算完毕后，外层的施放数应该跳过内层部分计算。 投射修正对且仅对所处的嵌套层内的所有投射物起效。 根据快速分析法，在《&lt;Noita&gt;法术编程指南》中提到的法术序列，可以在快速计算完施放数后，拆分成如下三部分： 对分段进行整理，法术序列最终变成了这样的嵌套关系，一目了然： ►大家都是投射修正！ ►多重施放可以当投射修正 既然多重施放并不造成嵌套关系，那么阵型法术并不能将后方的法术单独囊括起来，组成一定的形状。 因此，阵型类法术实际上以类似投射修正的方式在一定角度内均匀顺时针分布所处嵌套层中所有的投射物。例如，阵型-分叉能够作为一个投射修正，被修正的投射物在 ±45° 的范围内顺时针均匀施放： 以此类推，阵型-前后、阵型-五边形、阵型六边形是在 ±180°，即一整圈的范围内均匀分布投射物，阵型-上下的范围则是 ±180°。阵型-三叉的范围比阵型-分叉的范围稍小一点，约为 ±30°。 当有多个阵型法术同时存在时，最左边的法术决定分布范围： ►投射物也可以当投射修正 事实证明，投射修正的分类并没有那么明确——部分投射物也能提供类似的效果。 例如玩家们喜闻乐见的火花弹，就提供了 +5% 暴击和 -1 度散射的修正效果。而这些修正效果，是对同一嵌套层内所有法术起效的。因此，当我们用丧心病狂的 20 个火花弹填满一个法杖，并让它们一次性发射出来的时候，每一发火花弹都有着 20 * 5% = 100% 的暴击加成，并且总共有 20 * (-1°) = -20° 的散射修正。每一发都精准而致命： ►法术池的透支 《&lt;Noita&gt;法术编程指南》一文中也提到了“法术池”这个概念：在切换法杖和编辑法术时，法杖会刷新它的“法术池”。有序法杖的法术池中全部法术按照玩家设置的顺序排列；而乱序法杖的法术池中的法术是随机打乱的。游戏施法时并不直接从法杖中读取法术，而是从法术池读取。 可以发现，如果一次施法用尽了法术池，则魔杖会立即生成新的法术池继续施法，同时魔杖开始充能。但是如果一次施法第二次用尽了法术池，施法将强制终止…… ——《&lt;Noita&gt;法术编程指南》 在法杖中放入两只带有定时的光剑。当游戏处理到第二个光剑时会发现：光剑还可以继续嵌套，而法术池已经耗尽。如果编程指南中的这段话属实，那么游戏会生成新的法术池，再次以相同的顺序供应两个光剑，用尽第二个法术池，强制终止施法。最终效果会是长度为四倍的光剑。然而 ，实际情况下射出的却是长度为二倍的光剑： ►有限的透支 通过在以下法杖最前端填充 1~4 个火花弹并进行实验，会发现：带有触发的火花弹进行透支法术池时，总是会恰好发射出前端的所有火花弹；并不会透支到带有触发的火花弹本身。由此可以得出，每次施放的总法术数量不得超过法术池的法术数量。 ►法术池何时刷新？ 如果在一只乱序法杖中放入魔法弹和带有定时的火花弹，按照编程指南的理论，如果第一个法术池是｛魔法弹，带有定时的火花弹｝，在射出单发魔法弹后，下一次射出带有定时的火花弹时会进行透支。如果在透支前刷新了法术池，由于法杖时乱序的，将有概率刷新出｛带有定时的火花弹，魔法弹｝这样的法术池。结果是会出现两个嵌套的带有定时的火花弹。然而事实上并不会出现这样的射击效果。 因此这里可以推导出关于法术池的第二条规律：当法术池透支出现时，游戏并不会立刻刷新法术池，而是从头再次使用原来的法术池。在计算完施放的所有法术后，再刷新法术池。 ►用投射修正射出子弹！ 以下是一个简单却有实用性的例子： 第一次点击鼠标，法杖会施放出带有加速修正的霰弹，法术池剩余一个降低散射。 第二次点击鼠标，由于降低散射是投射修正，不减少施放数，游戏透支法杖，从头获取加速修正和霰弹。第二次的法术组合是｛降低散射，加速，霰弹｝。之后，法杖重新充能。 这样编排法杖的好处量两个：如果充能时间大于施放延迟，适当将投射修正置后可以利用法术池透支机制，实现每次充能可以设计两次的效果。另外，这样编排可以让霰弹第一发保持散布，第二发降低散射，集中火力，并且同时具备加速的修正效果，可以同时打击体积小、数量多和高生命、数量少的怪物。 ►综合性例子 这里举一个综合性较强的例子，完整阐述一下这篇文章提到的机制： 首先注意到法杖的施放数是 2，因此第一次施法会毫无悬念地发射出一发霰弹和一发火花弹（没有加速修正）。 第二次施法从加速修正开始。三重施放与阵型-背后使定时火花弹的施放数量达到 1 + ( -1 + 3 ) + ( -1 + 2 ) = 4，但是定时火花弹的右侧只有三个普通火花弹，于是需要从头透支法术池。目前施放了 8 个法术，法术池有10个法术，因此可透支上法术池最开始的一颗火花弹，于是定时火花弹攒齐了四个投射物法术。 这时候不要忘了法杖的施法数是 2。由于目前施放了 9 个法术，可以继续“透支”法术池。再加上霰弹，法杖的两个施法数也被满足了。 将第二次施放的法术序列按照嵌套关系分段后，效果如下图所示： 最后统计一下所有的投射修正：法杖直接发射的定时火花弹与霰弹都是有加速修正和火花弹的 +5% 暴击修正的；定时火花弹触发的四个火花弹都有沉重一击修正和四个火花弹提供的 4 * 5% = 20% 的暴击修正。另外，阵型-背后使得这四个火花弹会在 ±180° 内均匀散布。 施放效果： ►鸣谢 Noita 贴吧交流1群的 谷戻り 创作的 《如何在&lt;Noita&gt;中打造爆款法术》（《&lt;Noita&gt;法术编程指南》）。没有这篇文章也就没有我今天想到的这些理论。 和他的交流也令我很受启发。 Bilibili 的 196⑨ 的一系列 Noita 直播和游戏录像。火花弹类似投射修正的效果是最早从他的视频里了解到的。直播和录播都做的很有意思。","categories":[],"tags":[{"name":"noita","slug":"noita","permalink":"http://lucunji.github.io/tags/noita/"}]},{"title":"TekTopia 教程：当上土皇帝（中期 + 后期）","slug":"tektopia-tutorial-2","date":"2020-08-22T06:59:46.000Z","updated":"2020-08-26T04:59:01.795Z","comments":true,"path":"2020/08/22/tektopia-tutorial-2/","link":"","permalink":"http://lucunji.github.io/2020/08/22/tektopia-tutorial-2/","excerpt":"在获得了20只农民和10只伐木工的时候，没有什么能阻挡你的发展了。","text":"在获得了20只农民和10只伐木工的时候，没有什么能阻挡你的发展了。 在完成了上一篇教程之后，你已经有了庞大的食物和木材供应。这时候只要不作大死（比如让一只5级红袍亡灵法师大开杀戒）是怎么也玩不崩的。因此，这一阶段的自由玩耍空间比较大。 这游戏好难…… 时不时听到别人说这个模组的难度设定不合理，玩起来十分难受。这里有必要说明几点. 首先，这个模组把发展村庄变成了经营类游戏，但是第一人称的玩家又不具有一般经营类游戏的上帝视角。在对村民进行微操的时候，玩家没法把鼠标移过去一点完事，而是必须找到村民并跑到面前操作。建筑物必须由玩家手动搭建，物资必须一个箱子一个箱子地慢慢检察，交易的时候也要自己携带物资…… 如果有玩家想加快这些环节的速度，完全可以加入更多的模组，例如用建筑小帮手辅助建筑，以及用应用能源之类的模组把仓库里的所有箱子并入网络统一管理。 其次，由于这个模组的作者 Tango Tek 之前经常制作刷铁塔这种丧心病狂的装置，在制作模组的时候自然要想方设法地防止玩家用自己变态的生产力让村庄一步登天。只有村民自产的绿色名字物品才能参与交易。如果玩家强行塞入一大堆白色名字的物品，村民用这些物品制作出来的东西也会是白色的。 所以这个模组游玩的一个原则是不直接干预村民的生产。玩家可以给村民补充大量的工具（桶除外），但尽量不要塞入农作物和矿物，否则就会看到满箱的白名物品，用不完也卖不掉。 最后，如果对村庄的物品产出效率不满意，但又无力增员时，可以简单地采用挂机方法：在离地至少128格处建立一个平台进行挂机，这样可以避免夜晚怪物在村庄里刷出。 对了，请开启 /gamerule doWeatherCycle 或者使用其它防雷措施 防止建筑（特别是门牌展示框）因为雷击而损坏。 挖掘与饲养 在拥有了相当数量的农民和伐木工之后，摆在面前的是两个发展方向：矿工-德鲁伊-铁匠 构成的矿业，和 牧场主-屠夫-厨师 构成的畜牧业。矿业需要大量村民参与，做出的工具既可以提升其它村民的工作效率，也可以卖给商人；畜牧业需要的人手较少，产物可以制作食物和书本，自用或进行交易，但是大量的动物每天都要消耗食物。 由于发展的自由度较高，我这里并不偏重任意一条路线，而是介绍一些比较重要的地方。接下来的文章基本上不会再提到农业和林业，这两个职业在原有的基础上按需增员，无非就是面多了加水，水多了加面。 先造了再说！ 在中期总是有那么一些万金油的职业和建筑的，而厨房和图书馆就是其中最重要的两个。 ►厨房 厨房和厨师可以在刚进入中期的时候就引入，目的在于增加可以批量交易的选项——交易只有批量化才会有足够的效率。由于土豆可以批量放入熔炉烧制，烤土豆成为了一个不错的大宗交易。4~6只厨师可以保证供应100人的村庄所需的食物，并且还剩下一大批烤土豆。 ►图书馆 图书馆则旨在提升村民的智慧等级。村民的技能等级的升级受到智慧影响，因此提升智慧可以让村民更快地熟悉手头上的工作。图书馆在高峰期可能会有全村总人数的四分之一左右，因此需要较大的面积。一般一个图书馆的空间要足够容纳全村三分之一的人口。因为同时看书的村民数量取决于书架的数量，图书馆内部需要放置书架——书架堆叠放置也能起到作用。你可以连着书架把附魔台搬到图书馆里。 ►学校 说到图书馆，就不能不提到学校。在大部分人口通过图书馆获得较高的智慧值之后，从别的村庄拉人或者招募流浪汉获取到的人口基础智慧值就低得多了。这个时候将村民从小培育就是一个不错的增员选择。 在建造出图书馆之后，可以先招募一名教师，但不急着建造学校。老师会在不教书的时候成天泡在图书馆里阅读提升智慧。等到决定培育儿童时再建起学校，这样教师就能乘势利用极高的智慧值快速提高教书技能等级。 另外，向教师提供一本书可以更快地进行教育（书不消耗）。 ►村民繁殖 村民在快乐值较高时睡觉会有几率掉落一个爱心形状的物品（伴随有音效和爱心粒子效果），概率随快乐值而提高。将爱心对着任意一张床使用，就可以消耗爱心召唤出一个小村民。通过在房间内设置虚空箱子之类吸引物品的其它模组的装置可以方便地收集爱心。 ►牧师 牧师可以给予其它村民祝福，将自己的牧师职业等级累加到对方的职业等级上，提高对方的职业等级。受到祝福的村民也会缓慢恢复快乐值。祝福每分钟施加一次，每次持续5分钟。 牧师也可以为自己和其他村民回复生命（同时也能回复对方与自己的快乐值）。它会优先给卫兵回复。 如果没有卫兵的话，牧师并非必须的职业。而且小规模的战斗中（清除一两只僵尸），有良好护甲的卫兵完全可以依靠食物自行恢复生命。 ►商铺 有点余钱的话可以建造一个商铺。商铺仅仅起到一个限制商人活动范围的效果，免得你在需要交易的时候满大街找他。商铺并不要求建筑物，你可以在地上竖根柱子，然后摆上门牌。 矿业发展 通过在底下挖出一个高二宽一的洞，并在洞外侧墙壁上放上门牌，就能建立一个矿井。 矿工会向前开拓矿井，而德鲁伊会填补矿井并刷新矿物。一旦矿井超出村庄范围，矿井会失效（门牌失去附魔光泽），并且德鲁伊不会对失效的矿井进行填补。因此根据矿工的数量招募一批德鲁伊也是十分必要的。 矿工、矿井和德鲁伊的合适的数量比例是：矿工是德鲁伊的两倍量，并且矿井是矿工的三分之四倍——德鲁伊只会填补没有矿工的矿井，略多的矿井可以轮换利用，防止过度开采。 12只矿工可以为整个村庄供应制作工具所需的铁，并且还能有剩余量给你中饱私囊。这时招募两三个铁匠，全村的工具就可以得到较好的提升了。在发展畜牧业之前，铁匠的“制作：剪刀”和“制作：桶”都可以先取消。 畜牧业 由于厨师制作面包的速度缓慢，仓库里经常能看到大批的小麦。除了换取绿宝石以外这些小麦还可以用来推动畜牧业的发展。 即使没有建造屠宰场，畜牧业也是可以提供交易用的羊毛和鸡蛋的。另外，鸡蛋、牛奶可以用于制作蛋糕（甘蔗种下后农民也会自动收获）。 事实上屠宰场的作用并不大——皮革护甲过于廉价，只会浪费商人每次随机到的交易。附魔师也可以不依赖屠宰场，只用甘蔗造纸并且不给装备附魔——附魔的装备无法参与交易。 ►动物机制 用栅栏围出一块地，并且在栅栏门边上贴上门牌，就可以做成牛圈/羊圈/鸡圈/猪圈了。除了鸡的体型是 1 以外，别的牲畜的体型都是 3 。每块用栅栏围出的区域所能承载的生物量即是区域的面积除以生物体型。农场主职业的村民每天都会喂养繁殖动物并搜集产物。 在动物数量大于区域承载数量后，农场主依然会喂养动物，但是动物不会繁殖。在动物数量大于区域承载数量的 75% 并且村庄有屠宰场时，农场主会将动物牵引至屠宰场等待宰杀。 村庄动物是指 由村民喂食绿色食物而繁殖出来的动物 ，玩家亲自喂食或者使用非绿色食物是得不到村庄动物的。在玩家进入栅栏内时，村庄动物会发光 以帮助玩家分辨。 只有村庄动物身上才能产出绿色物品。 因此在动物繁殖出足够数量后应该将非村庄动物杀死，防止仓库混入白色原材料。基于同样的原因，在清除非村庄生物之前最好不要让村民收集物资，并且不让村民从野外找回动物（“寻找迷路的动物”选项）。 啤酒馆与武装斗争 最后是两个看起来没有太大作用的建筑：酒馆和兵营。 酒馆可以配合吟游诗人，为村民回复快乐值。然而只要住房有着充足的面积和休息的椅子，即使只提供单一简陋的食物，村民也能维持一定的快乐值避免疲劳。 建造兵营当然比不过将村庄附近128格内全部插满火把——如果不插火把的话，一小群卫兵是难以防住来势汹汹的僵尸的，更别提死灵法师了。 当然，如果你想让兵营发挥出它的功能，或者想欣赏一出卫兵与死灵法师之间的好戏，20~30只卫兵才能较好地在较大的压力（例如一只5级死灵法师）下守卫好一个村子。给士兵配备护甲和武器、一定数量的随行牧师，还有将他们升级到卫兵队长（卫兵队长只能由卫兵升级而来，不可以直接从其他村民转职），在村庄外围设置岗哨（岗哨类似商铺，无须建筑物）都可以提升他们的战斗力。 最后 最后，希望大家能从这个模组里获得快乐。在此放上我的生存存档截图：","categories":[],"tags":[{"name":"minecraft","slug":"minecraft","permalink":"http://lucunji.github.io/tags/minecraft/"},{"name":"mod","slug":"mod","permalink":"http://lucunji.github.io/tags/mod/"},{"name":"TekTopia","slug":"TekTopia","permalink":"http://lucunji.github.io/tags/TekTopia/"}]},{"title":"TekTopia 教程：开始打造你的桃花源（前期）","slug":"tektopia-tutorial-1","date":"2020-08-20T01:54:29.000Z","updated":"2020-08-20T05:35:57.726Z","comments":true,"path":"2020/08/19/tektopia-tutorial-1/","link":"","permalink":"http://lucunji.github.io/2020/08/19/tektopia-tutorial-1/","excerpt":"一个刷铁塔大佬会做哪些事？ 玩音游；烹饪；写 mod 答：以上全部[1]","text":"一个刷铁塔大佬会做哪些事？ 玩音游；烹饪；写 mod 答：以上全部[1] 也许是天天和原版的村庄机制打交道从而获得了灵感，又或者是受到了村民机制更新的启发，总之，Tango Tek 在 2019 年推出了自己的村庄 mod：TekTopia。由于这个模组的名字是 Tango Tek 的昵称加乌托邦（Utopia）的复合词，他的中文译名就成了：桃花源记/特克托皮亚。 与其说这个模组是 1.14 的村庄改版的另一种可能性，不如说它完全改变了原版村庄的设计思路。它不像原版那样结构松散又有很高的可玩性和魔改余地，也不像千年村庄（Millénaire）模组那样做成了类似 RPG 的样子，而是采用了一种类似经营游戏的概念：你需要监测村民的粮食、健康以及心情，并且进行交易，发展村庄。 模组搭配 TekTopia 这个模组并没有对其它模组做出任何兼容，并且这个模组里只有有村民自产绿色名字物品才能参与绿宝石交易。所以其它模组的选择要从这几个方面考虑： 加快跑图速度，减少跑图时间。如各种点对点传送和快速移动装置； 方便搬运村民。例如大师球、套索、召唤师灵摆甚至最无脑的水桶（Get In The Bucket Mod）； 方便建造建筑以及让建筑变得美观，例如建筑小帮手、建筑之杖和凿子； 加载区块。 另外以下类型的模组虽然能加速游戏进度，但是可能对游戏体验造成破坏： 加速火把 高效产出铁、钻石甚至铁镐、钻石镐，为村民提供高效的工具； 高效产出原版的食物； 高效产出绿宝石； 直接把村民塞进各种刷怪装置然后接上电无限刷村民 除此之外，可以安装 Tektopia Harvestcraft Compact 来提供对 HarvestCraft 的兼容。并且在 mcbbs 的介绍帖子里下载到使用中文姓氏版本的翻译文件。 另外，类似潘马斯模组的菜园这样的不完整方块可能会干扰村民的寻路系统。 进入村庄 首先你需要找到或者创建一个村庄。游戏生成的村庄已经有一定的人口基数和特殊职业，但是发展势必需要拆除并重建部分建筑。重新创建一个村庄不需要重新规划，并且对环境选择的自由度比较高，但是初始人口很少。 一个合适的地理位置需要一大片比较平坦的地理环境，并且周围没有森林。同时，你应当收集了甜菜、小麦、萝卜、土豆四种作物，以及云杉、橡树、白化、丛林（丛林不做硬性要求）这四种树。 ►自然生成的村庄 自然生成的村庄最好有一只吟游诗人。牧师类似吟游诗人，但由于作息时间和农民不同步以及技能不是群体的，只能是吟游诗人的下位替代。德鲁伊不是必须但是后期会很用得着。卫兵和无业游民（也就是绿衣服的“傻子”）完全用不着。铁匠职业前期会干扰交易选项，完全不需要，可以用道具收进背包，移出村庄或者杀掉。 ►从零创建村庄 首先合成一个村庄大厅的标志（以下简称为“门牌”），然后把它贴在一个封闭且有门的建筑物的门边上，然后稍作等待。 然后大厅里就会出现两个村民，并且赠送一个奖励箱。奖励箱包含两个门牌和两个职业标志。 前期发展 ►村庄大厅 刚才提到的村庄大厅是整个村子的地理中心。村庄的范围就是以它为中心的，边长两百多格的一个正方形。当走近村庄边缘的时候会出现蓝色的无遮挡作用的屏障提示。 村庄大厅里有两个人，分别可以用绿宝石交易到门牌和职业标志。随着交易次数的增多，交易的价格也会上升。 在没有做好应对死灵法师这种比较强大的怪物时，对着大厅门牌右键将它在展示框里旋转一下，就可以防止死灵法师刷出。等到准备充分以后可以摆正门牌，死灵法师会恢复刷新。 ►仓库 仓库是一个有着箱子门牌的封闭建筑，内部放有箱子和工作台。自然生成的箱子有绿宝石、命名牌之类的奖励。你应该增添一些箱子、工作台和熔炉。村民会在工具损坏并且箱子里没有存货的时候用箱子里的木头在合成台自己合成工具。 物品在村民之间流动的唯一方式就是通过仓库：一个村民把产品存进去，另一个再按需拿取。因此，它应当尽量贴近村庄中心放置，缩短村民路上行走花费的时间。 你也可以在仓库里放入你的物资，例如工具、食物和煤炭等。虽然这些物资不是村民自产的，他们也会按需拿取。 ►招募人员 获得村民的方法有三种，对着在村庄四个角落生成并移动到村庄中心的流浪者右键使用职业标志；从其它村庄把村民搬运过来；快乐值较高的村民会自动繁殖（比较繁琐）。前期一般只会使用前两个，并且主动搬运村民不消耗职业标志，更加经济。 招募人员时优先考虑智慧等级。职业等级在低于智慧的时候提升很快，超过智慧等级后提升很缓慢。前期没有图书馆时智慧没法提升。因此一个高智慧但是没有职业等级的村民会明显优于另一个高职业等级，低智慧的村民。 ►住房 住房是村民恢复快乐值的重要场所。有三种门牌：双人间、四人间、六人间。为了减少占地面积提高效率，尽量造大房间，但是也没有必要在已有小房间门牌的情况下强行购买大房间门牌。在别的村庄要记得收集六人间的门牌这种免费的资源。房子应该建得集中来提高效率。你甚至可以建设多层房屋进一步节约用地。 房间内根据门牌放下对应数量的床。每张床边上附带一个椅子以提高快乐值回复效率。另外房间内平均每个村民要有12格的地面空间。 ►防止房屋过于拥挤！ 各种住房、仓库、学校、酒馆等封闭建筑需要避免拥挤。建筑内的每个村民要保证 12 格的地面空间。工作台、熔炉、床、椅子、书架、铁砧、附魔台等特殊方块不占据地面空间。如果建筑内的人均占地面积小于十二格，村民会减少快乐值。人均面基越小，快乐值减少越快。 例如：一个6人间应该是 12*6=72 的大小。仓库不是专用空间，人口流动性较大，前期可以按照 4~6 个人来计算（游戏生成的仓库面积前期够用了），后期再进行扩建。学校、酒馆、图书馆等中后期建筑是聚集性场所，需要特别大的面积。 ►农民 农民推荐从其它村庄直接搬过来，但是记得要安排住房。 农民是整个村庄里最核心、最重要的人员。 村庄的发展程度可以单凭农民的数量断定。农民生产的作物要用来养活整个村子的人并且参与交易。前期以拥有 10 只农民为佳，当然农民永远也不嫌多。 ►农田 农田需要一个有水的，足够亮的（自然光或人工光源均可）区域。之后村民会自动开垦，但是比玩家手动开垦慢得多。应该用非泥土材料把农田圈出来，防止村民一直扩展农田。除非农田上已经有作物播种，村民不会自动去种植作物。村民种下作物的种类是根据周围种植的作物进行判断的，只要不同种作物的耕地隔开，一块田的作物种类就永远不会变。 农田应当大而集中 较好的方案是大量建设中央一格水的 9x9 农田。每种作物至少占据一块 9x9 的农田，最好占据两块。自然生成的小块农田都可以通过填上水源并移除作物的方法予以拆除。农民会优先选择更大、离中心更近的农田进行耕种。农民白天主要待在农田劳作，因此农田不用离中心太近。 ►伐木工 伐木工用斧子砍伐村庄范围内的树木。他会在砍倒树木后收集木头、树苗并补种（如果有同类树苗的话）。由于模组算法限制，他们不会砍伐 2*2 的大型树木以及金合欢树。最下面一格木头不接触泥土的话，伐木工不会砍伐。 由于伐木工每砍下一棵树木都要返回仓库存放，树场应该尽量靠经仓库设计。每种树都要大量种植。树苗间隔一格基本可以同时保证种植密度和树苗产出。记得清理村庄附近的树，防止伐木工就为了砍一棵树走半天路。 ►吟游诗人 吟游诗人可以在村庄各处演奏，并且恢复自己的与周围村民的快乐值。村民的快乐值过低会减少工作效率，所以前期拥有一只吟游诗人会有极大的帮助。 吟游诗人并不需要酒馆！ 前期并不需要去建造酒馆，酒馆严格意义上并不是吟游诗人的工作场所。 ►商人交易 在早上，商人会和流浪者一样从村庄的四个角落刷出。如果商人无法刷出或刷出后无法找到前往村庄中心的路，游戏会在聊天栏作出提示。 如果商人和流浪者一直不刷出或者刷出后不走动，地形也足够平坦，那可能是区块加载的问题，建议提高视距甚至放区块加载器。 商人会根据村庄内村民的类型随机提供一些能换取绿宝石交易。在前期自然就是四种作物和四种木头的交易。他会记住最近的 30 次交易。同一种物品过多地卖给商人会导致收购价下跌，甚至交易消失。这时需要出售其它物品来刷新最近的交易记录。这是这个模组发展的另一个要点：在保证大批量生产的同时增加产物多样性。 同一种商品一次可以交易五六次，因此较好的策略是将同一物品攒够多次交易的量后一口气卖出，防止价格下跌。 另一种技巧则是前往其它村落进行交易。由于商人的交易是根据村庄而定的，所以前往其它村落进行倾销也是个不错的选择。 前期的发展 根据上文建设好建筑物并招募了一定量的村民以后，可以开始发展了。要记得保持农民的数量，同时慢慢攒出好几组村民自产的物资进行交易。 可以选择离地面至少128格的高空挂机，这样可以防止刷怪又不用大范围插火把。 在有了绿宝石后，如果没有吟游诗人优先补充一只，然后逐步增加农民和伐木工的量。 在这期间，农民和伐木工以外的其它职业都不要考虑。 等到有 10 个伐木工和 20 个农民的时候，就从前期基本过渡的了中期。 主要参考 本文主要参考了官方维基和 mcmod 上的教程，不再在文章仔细列出引用。 玩音游：红云；烹饪：小墨 ↩","categories":[],"tags":[{"name":"minecraft","slug":"minecraft","permalink":"http://lucunji.github.io/tags/minecraft/"},{"name":"mod","slug":"mod","permalink":"http://lucunji.github.io/tags/mod/"},{"name":"TekTopia","slug":"TekTopia","permalink":"http://lucunji.github.io/tags/TekTopia/"}]},{"title":"【译】科技能救我们于深度伪造之中吗？","slug":"can-tech-save-us-from-deepfakes","date":"2020-07-22T10:03:48.000Z","updated":"2020-07-22T10:20:57.015Z","comments":true,"path":"2020/07/22/can-tech-save-us-from-deepfakes/","link":"","permalink":"http://lucunji.github.io/2020/07/22/can-tech-save-us-from-deepfakes/","excerpt":"","text":"►原文链接：https://moondisaster.org/can-tech-save-us-from-deepfakes/ ►作者：Pakinam Amer ►翻译：DeepL翻译 + 禄存天玑后期润色 ►译者注：仅对原文进行翻译搬运，旨在拓宽大众视野，不代表译者立场。以下的“deepfake”一律使用“深度伪造”作为译名。 ►当深度伪造变得越来越复杂，算法能够检测并排除它们吗？ 深度伪造比以往任何时候都要强大而普遍。依赖于逼真的图像与完美合成的人类语音，这些复杂的后期编辑的视频被人工智能软件生成出来了。 即使是迪士尼也在投资深度学习驱动的技术。在2020年初发表的一篇论文中，来自迪士尼研究工作室的科学家们声称，他们已经成功地训练了一种算法，来以前所未有的高分辨率质量在图像和视频中呈现照片般逼真的换脸。论文作者写道，这家娱乐巨头希望在需要将演员描绘得更年轻，无法使用演员使用这种特效，其他一些场合使用这项特效。 在网飞（Netflix）最近的影片《爱尔兰人》（The Irishman）中，罗伯特·德尼罗（Robert De Niro）在倒叙片段中被“返老还童”了。（来源：卢卡斯影业有限公司） 但即使在这种技术成为主流的时候，围绕着它的使用仍有未解决的忧虑。从网络上开始出现模仿、政治讽刺和假名人色情视频的那一刻起，人们就对深度伪造喜忧参半。据人工智能公司 Deeptrace Labs 去年发布的一份报告估计，目前大约有4.9万个深度伪造在流传，但社交平台上的换脸滤镜和由面部识别引擎驱动的应用程序的快速增长意味着可能还有成千上万个。 艺术家和记者最近一直在探索如何建设性地利用该技术来创造社会和政治评论，或保护边缘化和高危群体的隐私。例如，获得奥斯卡奖提名的纪录片制作人大卫·法兰西（David France）在上周于HBO上映的启示性影片《欢迎来到车臣》（Welcome to Chechneya）中，利用深层伪造技术掩盖了车臣同性恋者的身份。该技术甚至被一位星战超级粉丝用来“修饰&quot;，以改善《星球大战：侠盗一号》中年轻的莱娅公主的客串。 但即便是个人和迪士尼这样的大型媒体公司将这项技术用于非恶意的目的，深层造假技术也正在引发关于假新闻、个人隐私和视频证据权重的激烈辩论。 Youtube 上“derpfake”频道的建立者使用深度伪造技术来改善《星球大战：侠盗一号》中年轻的凯丽·费雪（Carrie Fisher）的外貌。建立者告诉卫报（The Guardian，英国著名日报），这个在上映几天就被观看了成千上万遍的工程，被在“用来看一季《辛普森》的时间里”做完了。（《辛普森》，即《辛普森一家》，The Simpsons，美国著名动画片，一季约20集，每集约20分钟） ►检测的挑战 1月，可能是为了在2020年大选前将问题解决在萌芽状态，Facebook 宣布将禁止扭曲现实或误导公众的操纵媒体。 这包括“在调整清晰度或质量之外进行编辑或合成的视频，其方式对普通人来说并不明显，很可能会误导别人认为视频主角说了他们实际上没有说过的话，”Facebook 全球政策管理副总裁 Monika Bickert 在一篇博客文章中写道。她补充说，音频或视频，无论是否深度伪造，也会受到Facebook的社区标准管理。如果包含裸露、图形暴力、压制选民或仇恨言论，就会被删除。 这个标准也适用于广告，不过《纽约时报》的报道指出，这一政策不会追溯标准制定以前的视频。 在全州范围内，加州已经先发制人地禁止在选举后60天内传播模仿真实镜头、故意伪造政治候选人言行的“恶意”操纵的视频、音频和图片。针对一段被篡改的南希·佩洛西（Nancy Pelosi）的，使美国众议院议长看起来像喝醉了酒的视频，提出该法案的议员马克·伯曼（Marc Berman）称深度伪造是“一种强大而危险的新技术，可以作为武器，在已经过度党派化的选民中播撒错误信息和不和。” 华盛顿邮报对南希·佩洛西被操纵的视频进行分析。该视频被放慢了速度，使她看起来口齿不清。（来源：华盛顿邮报） 去年，美国参议院通过了“深层假消息报告法”，要求国土安全部每年对深层假消息和任何试图“破坏民主”的人工智能驱动的媒体进行研究。 纽约大学法学兼职教授保罗·巴雷特（Paul Barrett）告诉NPR的“巨魔观察&quot;（Troll Watch），虚假信息越来越多地针对图像，而不是文字。“任何具有基本编码知识和“渴望在选举中捣乱的人都可以开始拼凑这些非常令人信服但虚假的视频，”巴雷特说。“而这些公司也意识到了这一点，并且正在争先恐后地，试图对此做出也许迟到的回应。” 现在知道立法能否成为阻止深层网络假货流传或病毒式传播的有效策略还为时过早，特别是考虑到搜索引擎无法进入深层网络的许多角落。另一个挑战是，这种法案可能会限制言论自由。因此，一些专家正在转向另一种遏制深度伪造浪潮的策略：以技术对抗技术。 ►以科技反科技？ 在识别深度伪造方面，技术专家和初创公司正在迎头赶上。然而，一些人正在投资开发面向未来的方法，以防范深度伪造的黑暗面。 6月，Facebook 公布了一项深度伪造检测挑战赛的结果，该挑战赛汇集了2000多名技术专家和人工智能研究人员，以创建和测试算法来检测Facebook制作的操纵视频。 在对 Facebook 的测试数据集进行测试时，表现最好的模型达到了 82.56% 的精度，但在对包含真实世界视频的“黑箱”数据集（这些视频通常是之前看不到的，而且更加复杂）进行测试时，准确率只有 65.18%。黑箱算法仍然是机器学习检测技术面临的最大挑战之一。 利用视频和技术策略揭露腐败和援助人权活动的国际非营利组织 Witness 一直在游说对媒体取证进行更好的投资，并称美国DARPA的MediFor计划是一个有希望的一步。 华盛顿特区的智库布鲁金斯研究所（The Brookings Institute）正在敦促政策制定者建立一个 “额外的资金流，用于开发新的工具，如反向视频搜索或基于区块链的验证系统，这些工具可能更好地坚持面对无法检测的深层伪造。” 该研究所还鼓励政策制定者投资培训记者和事实核查员，并支持与基于人工智能的检测公司合作。 Deeptrace Labs 就是这样一家检测公司。这是一家利用深度学习和计算机视觉来检测和监控深层伪造的初创公司，它将自己宣传为对抗基于人工智能的病毒式合成视频的 “杀毒软件”——这不失为深层技术前沿的智慧之战的证明。 Deeptrace 正在开发分析检测假视频的后端系统。它可用于个人用户和媒体公司，帮助他们识别伪造。“这句标语很好地概括了我们如何看待这个问题的一些表现方式，以及我们如何看待预防这个问题的潜在技术解决方案。”Deeptrace实验室的传播和研究分析主管Henry Ajder说。 Reality Defender 是另一款智能软件。它在你浏览网页时与你并肩作战，检测潜在的虚假媒体并提醒用户注意它的存在。 科学家们也是这场战斗的一部分。加利福尼亚大学河滨分校电气和计算机工程教授、智能系统研究中心主任 Amit Roy-Chowdhury 开发了一种深度神经网络架构，可以识别被篡改的图像，并以前所未有的精度识别伪造品。 Roy-Chowdhury 的系统可以通过检测物体周围边界每一个像素的质量，来分辨出被篡改的图像和未篡改的图像。如果图像被篡改或修改，这些边界可能会被“污染”，因此可以帮助研究人员精确地确定任何医生的位置。 虽然他的系统适用于静态图像，但理论上，同样的原理——经过一些调整——可以应用于由数千帧和图像组成的深层伪造视频。 但是，尽管做出了扎实的努力，大多数研究人员都认为，在外部环境检测深度伪造的过程是一个完全不同的比赛。另外，大体上，这些实验性的检测技术只掌握在专家手中，一般人无法接触到。 ►但科技不是万金油 “随着我们的技术越来越好，打击深层假货将变得越来越困难，”麻省理工学院计算机科学副教授 Aleksander Madry 说，他的研究解决了计算和开发值得信赖的人工智能的关键算法挑战。“所以目前这更像是一场猫捉老鼠的游戏，人们可以尝试通过识别一些假象来检测它们，但随后对手可以改进他们的方法来避免这些假象。” “更好的方法可能会欺骗检测机制，” Roy-Chowdhury 同意。这位计算机科学家说：“我们极不可能有一个系统能够检测到每一个深层伪造的东西。通常情况下，安全系统是由链条中最薄弱的环节来定义的。” 根据麻省理工学院计算机科学与人工智能实验室教授尼克-罗伊的说法，科学家们经常在黑暗中工作。Roy说：“在很多情况下，科学家不知道神经网络在做什么。”他对人工智能、机器学习和计算系统的研究主要集中在不确定性导致的问题上。 科学家“不能总是在出错的时候进行解释。神经网络不是黑魔法。我们确实了解很多基础知识，但我们没有掌握极限的……我们需要了解极限是什么，”他解释说。 随着基于深度学习技术的能力不断发展，Madry 说：“我担心的是，我们将不再能够自动依赖视频作为证明。” ►深度伪造与检测技术的未来 对于生成较差的深层伪造视频——那种通常由粗制滥造的编辑导致的明显皱纹——智能软件和知情的眼睛很容易发现篡改。但是，随着合成视听媒体开发者对这些问题的解决，发现伪造的迹象将变得更加困难。 前些年，研究人员通过监测眨眼频率来训练软件发现深层伪造。人类平均每分钟眨眼17次，但旧的深度伪造视频的眨眼频率往往远低于此。“如果你看的是2018年1月的视频，缺乏眨眼的情况很可能还适用于那里，”阿杰德说。“但比如说在接下来的一年，或两年，或五年，就无法依赖这一点进行衡量。” 同样，随着深度伪造的发展，依靠训练人工智能的，针对对编辑错误（如移帧和灯光或肤色的变化）的检测工具可能很快就会过时。 阿杰德说，他有信心，他所说的一些假媒体的“民间检测”方法，绝大部分“几乎肯定会被训练出高级版本。只有在谨慎应用并结合分析方法的情况下，它们才会有用。” 另一个问题是社交媒体平台所使用的分享技术，它可以让深层假货在不被发现的情况下倍增。 例如，德雷克塞尔大学助理教授马修·斯塔姆（Matthew Stamm）去年在西南偏南会议上表示，一些检测技术会寻找“非常微小的数字签名”，这些签名被嵌入到视频文件中。但当视频文件被分享到社交媒体上时，它被缩小和压缩，这就消除了所有被篡改的迹象。 “有很多图像和视频认证技术存在，但有一处他们都失败了，就是在社交媒体上，” 斯塔姆说。 同时，纽约大学法律系的巴雷特力劝人们“高度怀疑对他们所见”，并表示公司应该对虚假信息采取积极行动，或许可以“降级”这些帖子或视频。“我认为，他们应该完全从他们的网站上删除这种材料，”他补充道。 最终，将需要新形式的集体行动来打击篡改视频的负面影响，特别是如果它们被用来制造虚假新闻，意图误导。这个问题已经很普遍，无法单独解决。人工智能公司、媒体监督机构、政府和个人必须分担责任，对事实进行核查，并决定什么是真相，什么不是。","categories":[],"tags":[{"name":"tech","slug":"tech","permalink":"http://lucunji.github.io/tags/tech/"},{"name":"ai","slug":"ai","permalink":"http://lucunji.github.io/tags/ai/"},{"name":"deepfake","slug":"deepfake","permalink":"http://lucunji.github.io/tags/deepfake/"},{"name":"ML(machine learning)","slug":"ML-machine-learning","permalink":"http://lucunji.github.io/tags/ML-machine-learning/"}]},{"title":"电梯","slug":"elevator","date":"2020-07-12T08:22:17.000Z","updated":"2020-07-12T10:06:05.419Z","comments":true,"path":"2020/07/12/elevator/","link":"","permalink":"http://lucunji.github.io/2020/07/12/elevator/","excerpt":"没人能准确说出这台玻璃电梯前往的最高层是第几层。电梯井数倍高于商厦本身，而凭空高出商厦的那部分自然没有任何中间楼层。也就是说，从大厦本身的第五层到电梯顶端的终点之间没有任何的停靠层。 上升不可撤销，下降亦然。","text":"没人能准确说出这台玻璃电梯前往的最高层是第几层。电梯井数倍高于商厦本身，而凭空高出商厦的那部分自然没有任何中间楼层。也就是说，从大厦本身的第五层到电梯顶端的终点之间没有任何的停靠层。 上升不可撤销，下降亦然。 全玻璃构造的轿厢在玻璃电梯井内被一根明显不够粗的缆绳悬着。缆绳刚好连着轿厢顶部的正中心。若是轿厢没人，它可以以轻微摇晃的态势有惊无险地保持平衡。 这种设计的本意应该是让乘客在上升过程中饱览城市风景。可惜轿厢的地板也是玻璃的，再加上这摇摇欲坠的结构，很难想象乘客还能有心情去浏览风景。 这座城市也没有什么风景。建筑都是式样较老，稀稀拉拉的。商厦——更确切地说是这个电梯井——算是附近唯一的高楼。而天空每天基本上都是凄惨的白色，佐以不多不少，刚好让人可以偷懒不带口罩的雾霾。 这栋大厦不仅有这一部电梯。边上的另一部电梯的式样是在小区商场中随处可见的全金属结构，可惜它只在较低的楼层徘徊，并不通向几十层的高空。 电梯的顶部确实存在着一个楼层，那是仅靠着电梯井悬在半空的真正意义上的空中楼阁。原本那里是废弃的，但最近有人在上面办了一个英语补习班。这座城市中一部分有着勉勉强强，还算殷实的家底的学生，让这座电梯开始忙碌起来。 那个办补习班的人，想必是个万里挑一的优秀教师？并非如此，只是这座小城并无其他在英语水平上勉强称得上出众的人。边上的S城固然有不错的教育资源，可S城的生活开销太大，与小城之间也隔了几个小时的路途。也没有多少人称那个年轻人为某老师。家长们叫他小某，学生们则直呼姓名。 电梯上去又下来了。电梯门打开的时候里面是空的，因此大致可以推断之前进入的那位成功登顶了。既然之前的人平安无事，那这一次应该也是安全的。不过如果上升到一半出了故障，后果是可想而知的。 但在玻璃的移门在身后关上后，手不假思索地按下了最上面的那个按钮。 电梯开始不紧不慢地上升。上升到一半的时候，由人导致的重心偏移使轿厢开始在电梯井里打旋。渐渐地，人开始用后背贴着玻璃壁，站也站不稳了。想在电梯里惊呼，但电梯里并没有其他人去听。两个人的重量对于这部电梯来说太过勉强了。又约莫过了半分钟，电梯终于到达顶端。晃动的轿厢和外面的地板间有三四十公分的空隙，但人终究还是迈过去了。 这样的光景，每天要重复上下两遍，每个月总共有大约十次。并没有谁看到工人来维修过电梯，仿佛电梯对于这些学生以外的其它人来说是不存在的。电梯这么运行了将近半年，有过好几次在半空中卡住，又恢复过来继续运行的奇迹，从来没出过人命。至于办补习班的那位年轻人是怎么上去的，似乎没有多少人思考过。 在数十米的高空乘坐如此摇摇欲坠的电梯，这似乎严重有悖于生命的本能。然而比起从数十米高空跌下来的后果，似乎有更加抽象而恐怖的东西在逼迫着这些灵长目动物。 后记 这篇文章来源于做过的梦。后来添加上一些别的东西，就作成了这篇文章。写的时候尝试把字数尽量压缩，居然也写出了一千来字。这篇文章的一个更为完整的标题可以是《电梯-小城与那群妄想逃离的学生》。可以算是魔幻现实。艺术来源于生活，但是麻烦不要对号入座，qqqxx（3q谢谢） 这篇文章的隐喻我觉得不难看出来。如果要我多说一点的话是这样的：这部电梯虽然有来有回，但是整个小城以及更大的环境使得这部电梯和它代指的一些东西变成了真正意义上的单行道。 另外，这篇文章是以我的主观感受写的，如果有不同的想法，很正常，说，都可以说。","categories":[],"tags":[{"name":"misc","slug":"misc","permalink":"http://lucunji.github.io/tags/misc/"}]},{"title":"关于 Minecraft 社区规范","slug":"on-minecraft-community-custom","date":"2020-04-18T11:11:58.000Z","updated":"2020-04-18T14:35:48.454Z","comments":true,"path":"2020/04/18/on-minecraft-community-custom/","link":"","permalink":"http://lucunji.github.io/2020/04/18/on-minecraft-community-custom/","excerpt":"目前的 Minecraft 社区中，一直存在着关于红石、建筑、指令各领域用户作品归属、使用、再创作等问题的争论。这些争议短则一天，长则一周甚至一月。这些争议很少能够被较为圆满地解决，而由这些争议所引发的社区中的进步就更是凤毛麟角。","text":"目前的 Minecraft 社区中，一直存在着关于红石、建筑、指令各领域用户作品归属、使用、再创作等问题的争论。这些争议短则一天，长则一周甚至一月。这些争议很少能够被较为圆满地解决，而由这些争议所引发的社区中的进步就更是凤毛麟角。 了解一些英文的读者可以看出，这篇文章的标题是 On Minecraft Community Custom，致敬了大作家蒙田的文章 On Custom。作为一次东施效颦，在这篇文章里我会尝试着以怀疑态度对一些 MC 社区中的观点进行反驳。此文仅代表我在写作此文时的态度——我的观点必然会随着时间或多或少地变化。另外，我也期待与各位读者进行相关话题的探讨。 为了讨论对 MC 玩家作品的使用和借鉴规范，我们回到问题的根本处。之所以需要此类探讨，是因为现存的法律体系难以给出一个令人满意的答案。将视野拉远，互联网的版权问题一直存在着争议：迪士尼层出不穷的版权官司，漫画本地化人员的冷遇，“搬运工”涉及到的种种争议。互联网上作品传播、保存、评论的简单快捷注定使得非互联网领域的版权规范在这里显得古板而笨拙。于是各个网络社区的用户都尝试着在表达创作的同时自行约定规范。经过较长一段时间的积淀后，这些零散的规范逐渐变得深入人心，由此便形成了各种社区规范习俗。MMD[1]会要求制作者注明“借物表”，即列出所使用的模型的作者；不去“本家”（即原作）刷翻唱也称成为音乐相关作品的礼仪规范。 然而，并不是所有用户社区都可以在这样的一个过程中形成一套自己的规范，Minecraft 社区就是一个例子。可以做出如下分析：由于入门 Minecraft 游戏并没有太大的难度，玩家并不会刻意地加入专门讨论这个游戏的社区。他们可以只是用这个游戏打发业余时间，与朋友联络。而另一些事物，例如 音MAD[2]，MMD 等，都对用户有着较高的入门要求。因此用户更倾向于加入一个专一的社区来更高效地提升水平。由于 Minecraft 用户完全可以游离于专门的社区之外，很难确保他们对于社区的规范有所了解。另外，Minecraft 服务器使得玩家更倾向于分散为更小的群体，各自为政。这些小群体内部往往有着比外部社区更高的交流。这些小群体之间并非没有交流，但是往往较难暴露出观点的一些差异。 这些关于作品所有权、使用方法的意见差异，往往会导致群体之间的争论，并且在这些争论中被暴露出来。不过由于缺乏有组织的、理性的思考，这些争论往往并不会产生什么真正有利社区的结果——休战只是为了双方止损，而观念的差异却没有被解决。持有不同意见的个人、群体之间难以建立有效的对话。观点的交流往往被妥协所取代。 在这些争论中，一种常见的观点是对现存版权法律的“拿来主义”。持有这种观念的人通常会使用现存法律条文中的规定来画出网络上侵权与非侵权的界线，并据此认为，应有的裁定已经完成，剩下的只是依照现有条文进行处罚。然而，在经过考虑以后，人们应该会发现这种思维只是图一时之方便的偷懒之举。这种观点错误地判断了原因与结果：因现有法律条文难以较好地适配网络社区，而需要对此乱象进行更细致的讨论；并非因现存的种种乱象，需要引用现存的法律条文来进行规范。如果现存的法律条文能较好地对网络社区进行规范，各种争执便不会产生。而目前出现的争论，正是现有条文无法维持社区秩序的印证。 于是，问题从来没有从根本上解决，因为这种生搬硬套往往难以让人信服。正如福熙对于第一次世界大战的评论[3]： This is not peace. It is an armistice for 20 years. 这不是和平。这是二十年的休战。 这种“拿来主义”是一种因恐惧争论进一步激化而不愿深入探讨问题的消极作风。不仅不能提供一种有效的解决手段，反而会使这个社区的成员产生一种“有法可依”的错觉。一旦类似争议再次爆发，用户便会出现一种奇妙的心理状态。他们对于被怀疑侵权者产生了一种犹如敌视罪犯一般的道德谴责，同时又对假定的秩序无法被有效遵守产生一种沮丧、悲观态度。于是常常会出现对被怀疑者的激烈声讨，与对社区整体的不信任。为了不使文章离题，这里不对常见的有罪推定、非黑即白等进一步激化矛盾的误区进行赘述，不过作为题外话，小心地求证，并大胆假设正方反方意见应当位列行为准则之中。 基于个人对目前 MC 社区的微不足道的观察，一种有效地改良方式应当是这样的：首先应当积极地推动不同小群体、不同小领域之间的对话。不仅要在争论的时候进行探讨，更要在平时进行探讨。在一时的争论中，对话双方可能会因为利益、公众影响等原因有所顾忌、有所保留；而在平时，双方一般会有较少的顾虑，也更容易心平气和地进行探讨。另外，不能完全摒弃现存法律的条文，而是有所选择性的利用。现存的条文通常是基于一定的假设和原则而制定的。当我们将这些条文搬到网络环境中时，需要考虑到他们所基于的假设是否在 Minecraft 社区中存在，是否在网络社区中产生了变化。这里的逻辑类似于知乎上的一段关于马克思主义的论述[4]： ……历史上并非先有了一套“不拥有生产资料”，“代表先进生产力”，“领导阶级”的论断之后，才有人去研究资本主义社会的弊病，经济剥削的本质，革命力量的所在。真正的逻辑是倒过来的，有了对社会现实的大量研究，对社会革命的强烈动机，为此结合实践创建了一整套理论体系，最后才有人去抽象出几个论断，方便人理解。 例如，创作者可以通过 Creative Commons 等协议注明自己保留、转让、放弃的权利。而具体到如何界定抄袭和侵权，可以由作者明确划出规范，也可以商量决定。海外 Minecraft 社区关于这一点上采取的措施可能可以起到不错的示范作用。 以上便是我对 Minecraft 社区中用户版权的一些思考。希望能为社区的良性发展起到贡献。 [1] 即 MikuMikuDance https://zh.moegirl.org/MikuMikuDance [2] 为日文音系MAD／音声MAD的缩略语，是一种使用素材中的乐器对所选BGM进行演奏的视频形式 https://zh.moegirl.org/音MAD# [3] Ruth Henig, Versailles and After, 1919-33 (Routledge, 1995), p. 52. [4] 作者：白头豕 链接：https://www.zhihu.com/question/36851145/answer/108617648 来源：知乎","categories":[],"tags":[{"name":"minecraft","slug":"minecraft","permalink":"http://lucunji.github.io/tags/minecraft/"}]},{"title":"简易修改 Minecraft 字节码","slug":"minecraft-bytecode-modding","date":"2020-01-16T08:13:34.000Z","updated":"2020-02-21T03:21:21.133Z","comments":true,"path":"2020/01/16/minecraft-bytecode-modding/","link":"","permalink":"http://lucunji.github.io/2020/01/16/minecraft-bytecode-modding/","excerpt":"100% vanilla!","text":"100% vanilla! ►简介 之前看到 1.15.2-pre1 更新了玩家种植树木也会刷新蜂巢的特性，研究完机制以后想着修改一下蜂巢刷新几率来方便测试。 可是这时候 fabric 啥的还没更新，于是想到了之前 EDDExample 说过的修改字节码大法。顺便用上 Mojang 1.14.4 以来的官方反混淆表。 EDDExample 在视频里用的是 JByteMod 来修改字节码。可以在 https://github.com/GraxCode/JByteMod-Beta/releases 下载到。 ►反混淆 前往 https://github.com/hube12/DecompilerMC/releases ，在 Releases for lazy users 下面下载适合操作系统的版本，这里就选择 Windows.zip。 将压缩包解压，会看到有一个 McDecompiler.exe 文件，运行后根据提示选择，依次输入 y，cfr，1.15.2-pre1 以及 y。 等待几分钟，程序运行完毕后就可以在 src 文件夹里看到反混淆好的源码；在 mappings 里看到反混淆表。 ►查找修改目标 通过在反混淆的源码中搜索，可以找到负责在树上生成蜂巢的装饰器 net.minecraft.world.level.levelgen.feature.treedecorators.BeehiveDecorator 这里通过产生一个随机的单精度浮点数，实现了蜂巢生成概率的随机化： 12345public void place(LevelAccessor var1, Random var2, List var3, List var4, Set var5, BoundingBox var6) &#123; if (var2.nextFloat() &lt; this.probability) &#123; //... &#125;&#125; 由于 Minecraft 中的类名、方法名是经过混淆的，我们无法直接查看字节码。在反混淆表中搜索类名 BeehiveDecorator，会发现它的混淆后的类名是 ciq，方法 place 混淆后的名称是 a。值得注意的是，一个混淆的类会包含多个同名但不同参数的方法，因此需要额外留心方法的参数数量和类型。 ►修改字节码 用解压软件打开版本文件 1.15.2-pre1.jar，单独拖出 ciq.class 文件，用 JByteMod 打开这个类文件，开始修改。 之前我试过直接打开整个 jar，结果修改后无法正常启动游戏。后来折腾了半天才发现单独拖出来修改类文件就好了。 首先定位到要修改的方法。之前找到的方法拥有6个参数，其中第2、3、4、5个参数的类型分别是 Random，List，List 以及 Set（Java 自带的类型一般不会被反混淆）。点开这个方法，发现开头的几行字节码分别是： 12345678910aload 2invokevirtual float Random.nextFloat()aload 0getfield float ciq.bfcmpliflt 2label 1returnlabel 2...... 通过翻阅 JVM 指令集，可以得知这几行指令的效果： 加载下标为 2，即类型为 Random 的传入参数的引用； 调用该对象的 nextFloat() 方法，返回一个 float； 加载下标为 0 的传入参数，即 this 的引用； 获取该对象的成员变量，对象属于类 ciq，对象名是 b，变量类型是 float； 比较 (2) (3) 两处的 float 值； 如果 (3) 处小于 (2) 处，跳转到标签 2 处执行剩余指令，否则继续往下执行 return 退出方法。 这几行描述的内容和反编译出来的 if (var2.nextFloat() &lt; this.probability) {} 对应。没问题，接着进行下一步。把前两行删去，替换成 ldc Float 0.0 就可以变成每次尝试必定成功的 if (0.0f &lt; this.probability) {}。 删除前两行 -&gt; 右键点击 getfield -&gt; 插入之前 -&gt; LdcInsnNode -&gt; 类型选择 Float，值输入 0.0。 完成后保存类文件，准备替换。 ►核心 jar 替换法 核心 jar 替换法，顾名思义就是直接替换 versions 文件夹中核心版本文件 1.15.2-pre1.jar 的类。为了防止游戏对 jar 进行完整性检测，需要删除 jar 中的 META-INF 文件夹，并且删除 1.15.2-pre1.json 中的下载链接。具体链接内容因版本而异，并且注意逗号： 1\"downloads\": &#123;\"client\": &#123;\"sha1\": \"9f28455f9f9d09294e0ba19beb13dc26b39a9582\", \"size\": 15531212, \"url\": \"https://launcher.mojang.com/v1/objects/9f28455f9f9d09294e0ba19beb13dc26b39a9582/client.jar\"&#125;, \"client_mappings\": &#123;\"sha1\": \"6c81c6f2e6ff0c3a2795f5d336c63b0740a60a45\", \"size\": 4971880, \"url\": \"https://launcher.mojang.com/v1/objects/6c81c6f2e6ff0c3a2795f5d336c63b0740a60a45/client.txt\"&#125;, \"server\": &#123;\"sha1\": \"5db50a719dc40d63aa95c6bdc5b302e425f673f2\", \"size\": 36175423, \"url\": \"https://launcher.mojang.com/v1/objects/5db50a719dc40d63aa95c6bdc5b302e425f673f2/server.jar\"&#125;, \"server_mappings\": &#123;\"sha1\": \"f59bfc0ebb62bc7802af0567ad79592274c56943\", \"size\": 3737013, \"url\": \"https://launcher.mojang.com/v1/objects/f59bfc0ebb62bc7802af0567ad79592274c56943/server.txt\"&#125;&#125;, ►运行 如果一切操作都没有问题，那么游戏将能够正常的启动。 创建一个新的世界，在花的边上种下一棵白桦树或橡树，必定会产生一个蜂巢。 ►MultiMC 配置方法 MultiMC 提供了方便的 Jar mod 安装方式。只要删除 META-INF 文件夹，就可以在 Edit Instance 中选择 Add to Minecraft.jar 或者 Replace Minecraft.jar，选择修改后的 jar 载入就可以了。 需要注意的是，再次修改 jar 过后，需要在列表中移除并重新加入修改后的 jar。 ►感谢 EDDxample，他在 YouTube 上有不错的关于代码和模组制作的视频 https://youtu.be/T_658BztqVE ，使用 JByteMod 的点子也是从这个视频里学到的。","categories":[],"tags":[{"name":"minecraft","slug":"minecraft","permalink":"http://lucunji.github.io/tags/minecraft/"},{"name":"Java","slug":"Java","permalink":"http://lucunji.github.io/tags/Java/"},{"name":"bytecode","slug":"bytecode","permalink":"http://lucunji.github.io/tags/bytecode/"}]},{"title":"附带 Mixin 的 Rift 开发环境配置方法","slug":"rift-with-mixin-setup","date":"2020-01-04T06:02:24.000Z","updated":"2020-07-12T08:26:11.345Z","comments":true,"path":"2020/01/04/rift-with-mixin-setup/","link":"","permalink":"http://lucunji.github.io/2020/01/04/rift-with-mixin-setup/","excerpt":"2020/2/20 更新：懒人用开发环境 https://github.com/LucunJi/Rift-MDK-with-Mixin 在 1.13.2 的 Minecraft 版本下，许多的模组并不依赖 Forge 或者 Fabric，而是 Rift。然而目前 1.13.2 现存的 MDK（Mod Develop Kit，模组开发包） 并不包含 Mixin。但是 Rift 提供的监听接口较少，很多功能都需要开发者自己利用 Mixin 来对原版代码（准确的说是字节码）进行修改。这里分享一下如何配置一个包含 Mixin 的 Rift 开发环境，帮有类似需求的人节约时间。","text":"2020/2/20 更新：懒人用开发环境 https://github.com/LucunJi/Rift-MDK-with-Mixin 在 1.13.2 的 Minecraft 版本下，许多的模组并不依赖 Forge 或者 Fabric，而是 Rift。然而目前 1.13.2 现存的 MDK（Mod Develop Kit，模组开发包） 并不包含 Mixin。但是 Rift 提供的监听接口较少，很多功能都需要开发者自己利用 Mixin 来对原版代码（准确的说是字节码）进行修改。这里分享一下如何配置一个包含 Mixin 的 Rift 开发环境，帮有类似需求的人节约时间。 ►基础环境配置 首先到 https://github.com/DimensionalDevelopment/Rift-MDK/tree/1.13.2 下载不包含 Rift 的 MDK 到本地。这时候文件结构看起来应该是这样的： 12345678910111213141516171819202122D:\\RIFT-MDK-1.13.2│ .gitattributes│ .gitignore│ build.gradle│ gradlew│ gradlew.bat│ README.md│├─gradle│ └─wrapper│ gradle-wrapper.jar│ gradle-wrapper.properties│└─src └─main ├─java │ └─example │ ExampleListener.java │ └─resources pack.mcmeta riftmod.json 这里使用 Intellij IDEA 为例子，选择 build.gradle 进行导入。导入完毕之后直接打开右侧 Gradle 面板，双击 setupDecompWorkspace 进行基本环境的配置。由于需要反编译并反混淆，可能会花上几分钟。等到显示 BUILD SUCCESSFUL，环境就搭建完毕了。 在这一步可能会遇到提示 Cannot find hunk target。这时候运行 cleanCache 清空缓存，然后重新运行 setupDecompWorkspace 就好。 接下来尝试启动 Minecraft。这里不能直接运行 runClient，应该运行 External Librarries（外部库）里的 start/net.minecraftforge.gradle/GradleStart，在 Program arguments 中填入 --tweakClass org.dimdev.riftloader.launch.RiftLoaderClientTweaker，并将 Use classpath of module 设置成 Rift-MDK-1.13.2.main。之后点击 Run，就可以运行 Minecraft 了。如果只运行服务端，那么可以把上面的 Program arguments 中的 Client 改成 Server。 ►配置 Mixin[1] ►修改 Gradle 配置文件 首先打开根目录下的 build.gradle，在末尾（或者按你的喜好排版）添加 Mixin 的插件、配置信息、仓库地址和依赖项： 123456789101112131415apply plugin: 'org.spongepowered.mixin'mixin &#123; defaultObfuscationEnv notch add sourceSets.main, 'mixins.example.refmap.json'&#125;buildscript &#123; repositories &#123; maven &#123; url 'http://repo.spongepowered.org/maven' &#125; &#125; dependencies &#123; classpath 'org.spongepowered:mixingradle:0.6-SNAPSHOT' &#125;&#125; 此时点击 Gradle 窗口左上角的循环标志（Reimport All Gradle Projects），应该会重新配置开发环境，出现 CONFIGURE SUCCESSFUL 说明配置成功。 ►Mixin 配置文件 在 src/main/java/resources 文件夹下创建 mixins.example.json，内容如下： 1234567891011121314&#123; \"required\": true, \"minVersion\": \"0.7.11\", \"compatibilityLevel\": \"JAVA_8\", \"target\": \"@env(DEFAULT)\", \"package\": \"example.mixin\", \"refmap\": \"mixins.example.refmap.json\", \"mixins\": [ ], \"client\": [ ], \"server\": [ ]&#125; ►初始化 Mixin Mixin 需要在 Minecraft 的类被加载前被启动。先在 src/main/java/example 包内创建类 ModInitializationListener 实现接口 InitializationListener。并且在实现的方法 onInitialization 中初始化 Mixin 并且加载配置文件 。全部代码如下： 12345678910111213package example;import org.dimdev.riftloader.listener.InitializationListener;import org.spongepowered.asm.launch.MixinBootstrap;import org.spongepowered.asm.mixin.Mixins;public class ModInitializationListener implements InitializationListener &#123; @Override public void onInitialization() &#123; MixinBootstrap.init(); Mixins.addConfiguration(\"mixins.example.json\"); &#125;&#125; 同时修改 riftmod.json，告知 Rift 加载器新增的事件监听器。修改后内容如下： 1234567891011&#123; \"id\": \"example\", \"name\": \"Example\", \"authors\": [ \"\" ], \"listeners\": [ \"example.ExampleListener\", \"example.ModInitializationListener\" ]&#125; 至此，Mixin 就配置完毕了。 ►试运行 首先创建包 example.mixin，并新建类 MixinLoadingGui，输入如下代码： 12345678910111213141516171819package example.mixin;import net.minecraft.client.Minecraft;import net.minecraft.client.audio.SimpleSound;import net.minecraft.client.gui.GuiScreenLoading;import net.minecraft.init.SoundEvents;import org.spongepowered.asm.mixin.Mixin;import org.spongepowered.asm.mixin.injection.At;import org.spongepowered.asm.mixin.injection.Inject;import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;@Mixin(GuiScreenLoading.class)public class MixinLoadingGui &#123; @Inject(method = \"onGuiClosed\", at = @At(\"RETURN\")) private void onRender(CallbackInfo ci) &#123; Minecraft.getInstance().getSoundHandler().play(SimpleSound.music(SoundEvents.ENTITY_GENERIC_EXPLODE)); &#125;&#125; 并且在 mixins.example.json 的 client 列表中添加这个类的类名（不用包名，因为已经指定好了），添加完后是这样的： 123456789101112131415&#123; \"required\": true, \"minVersion\": \"0.7.11\", \"compatibilityLevel\": \"JAVA_8\", \"target\": \"@env(DEFAULT)\", \"package\": \"example.mixin\", \"refmap\": \"mixins.example.refmap.json\", \"mixins\": [ ], \"client\": [ \"MixinLoadingGui\" ], \"server\": [ ]&#125; 接着启动游戏。如果一切没有问题，在游戏加载完毕后会听到一声爆炸 “轰！” ►拓展阅读 Mixin 官方文档：https://github.com/SpongePowered/Mixin/wiki 官方文档中文翻译：https://mouse0w0.github.io/2018/11/07/Introduction-to-Mixins-Overwriting-Methods/ 国内的教程 CoreModTutor：https://xfl03.gitbook.io/coremodtutor/5/5.1 ►参考资料 Rift-ModList 作者：shedaniel https://github.com/shedaniel/Rift-ModList ↩","categories":[],"tags":[]},{"title":"浅谈活塞破基岩法的不稳定性起源及解决方法","slug":"bedrock-breaking","date":"2020-01-02T22:28:59.000Z","updated":"2020-01-07T20:41:32.789Z","comments":true,"path":"2020/01/02/bedrock-breaking/","link":"","permalink":"http://lucunji.github.io/2020/01/02/bedrock-breaking/","excerpt":"本文针对最早由 Myren Eario 提出的利用活塞移除基岩的方法所存在的不稳定性进行分析，并提出一种可行的解决方案。","text":"本文针对最早由 Myren Eario 提出的利用活塞移除基岩的方法所存在的不稳定性进行分析，并提出一种可行的解决方案。 ►原方法简介 基岩在 Minecraft 无法被生存模式下的玩家通过挖掘的方式破坏。但是由于高效刷怪塔、凋灵相关设施、地狱交通等需求，玩家有时需要移除基岩来完成某个工程。于是，陆续有玩家发现了 Minecraft 程序中的漏洞，并开发出了一些移除基岩的方法。 最早在 2016年5月3日，Myren Eario 在 YouTube 上发布了一个利用活塞和 TNT 移除基岩的方案[1]。不过由于这个方案存在随机性，并且当时还有稳定性更高的弱加载区块龙蛋移除法，该方案并没有受到较大的关注。但在 1.13 修复了龙蛋相关的漏洞之后，玩家只能利用活塞来移除基岩。本文中提到的这个方法的应用开始变得广泛了。 ►复现过程 如上图所示，使用该方法需要一个伸出的活塞（粘性或普通的均可）和一个 TNT（图中白色的即为点燃的 TNT 实体）。玩家需要不断尝试按下右键，在源活塞底座的位置放置一个朝向基岩的活塞。如果不使用辅助放置的模组的话，这里需要一个不会被爆炸破坏的方块（如黑曜石）作为放置的参照物。 在保证右键点击的频率足够高的前提下有几率会将原先被活塞背对的基岩移除，并留下一个活塞方块。 这个方法的变体可以在其它的视频中看到。例如：活塞可以朝上放置以从上往下移除地狱上方的基岩层。[2]在右侧红石块上放置 TNT 后，装备鞘翅的玩家快速双击空格缩小碰撞体积，钻入楼梯下方（在 1.14 以及之后的版本中可以用活板门下压法替代） 之后对着黑曜石离自己最近的上棱角快速点击右键，就可以达到和 Myren 的方法相似的效果，移除基岩。 ►方法原理 根据游戏事件顺序[3]可以得出以下事件顺序： TNT 爆炸： TNT 实体在 Entity Update 阶段引发爆炸，破坏活塞底座、活塞臂和信号源。 若信号源先于活塞底座或活塞臂被破坏，活塞接收到方块更新，并计划在下一次的 Block Event 开始收回动作。接着活塞被破坏，掉落； 若活塞底座或活塞臂其一先于信号源被破坏，则活塞整体会被破坏并掉落，不会在下一次 Block Event 进行动作； 活塞在被破坏后不撤回 Block Event 中的计划。 玩家放置： 在 Network Update 阶段（这里采用另一篇文章[4]的习惯，将玩家更新相关的阶段合二为一），服务器处理发出放置活塞的数据。由于该位置原有活塞已被摧毁，活塞被成功放置并面朝基岩。 移除基岩： 如果在 1 中的信号源被最先破坏，那么下一 gt 的 Block Event 中，会在原有活塞的位置进行收回动作。由于游戏在这时 不检测活塞朝向，会根据新放置的活塞进行从下往上的收回。由于游戏尝试把不存在的活塞臂从基岩的位置抽回，基岩被替换成了空气方块。新放下的活塞本身变成了一个 36号方块。 剩余步骤： 剩余步骤为：36号方块在经过 3 个 Tile Entity Update 之后变为一个与最初的活塞朝向一致的收回的活塞。 以上便是活塞移除基岩的事件顺序。不难看出成功的关键在于步骤 1 中爆炸破坏方块的顺序，以及 2 中玩家是否能及时发送尝试放置方块的数据包。最后一步完全由稳定的游戏机制保障运行，无须担心。 步骤 2 可以由一个稳定的外部连点器软件，或者一个快速点击的模组保证，于是唯一难以解决的问题出现在步骤 1 上，而这也是一般人所知的不稳定性的来源。 另外，由于有时基岩无法移除是因为玩家在 2 中放置的活塞朝向并不与原有活塞相反，这里提出一个判断玩家操作是否正确的方法。观察 4 中最后产生的活塞，如果朝向与最初活塞相反，那么可以认为操作无误。否则可能是操作不当。 ►不稳定性起因 在实际操作过程中不难发现：装置、操作方法一致，但在不同的位置会产生不同的效果。有点位置能够移除基岩，而有的则不能。而且即使位置相同，TNT的摆放位置不同，结果也不同。 举个例子，在 1.13.2 中的 x=48, y=1, z=-6 位置放置一个向上的活塞，它的北侧放置黑曜石，南侧放置红石块，采用上文提及的 newcake 的方法。当 TNT 被放置在红石块上引爆时，无法移除活塞正下方的基岩；而当 TNT 被放置在伸出的活塞臂上引爆时，可以移除基岩。 根据上一章节的分析，在排除玩家操作失误的因素后，唯一的问题在于爆炸破坏方块的先后顺序。因此这一章对爆炸部分的游戏源码进行阅读、分析，旨在找出不稳定性在 Minecraft 中的起因。 这里的源代码来自 1.13.2 Rift 模组开发环境自带的 Minecraft Coder Pack。爆炸相关的 Java 类是 net.minecraft.world.Explosion，主要法方法有两个：doExplosionA() 统计所有需要被破坏的方块，并伤害实体；doExplosionB() 破坏统计的方块，产生方块掉落物并显示粒子效果。 首先是 doExplosionA() 中的代码： 点击展开代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public void doExplosionA() &#123; Set&lt;BlockPos&gt; set = Sets.&lt;BlockPos&gt;newHashSet(); // 与 Set&lt;BlockPos&gt; set = new HashSet&lt;BlockPos&gt;(); 等价 int i = 16; for (int j = 0; j &lt; 16; ++j) &#123; for (int k = 0; k &lt; 16; ++k) &#123; for (int l = 0; l &lt; 16; ++l) &#123; if (j == 0 || j == 15 || k == 0 || k == 15 || l == 0 || l == 15) &#123; // 产生爆炸射线 double d0 = (double)((float)j / 15.0F * 2.0F - 1.0F); double d1 = (double)((float)k / 15.0F * 2.0F - 1.0F); double d2 = (double)((float)l / 15.0F * 2.0F - 1.0F); double d3 = Math.sqrt(d0 * d0 + d1 * d1 + d2 * d2); d0 = d0 / d3; // 计算成单位向量 d1 = d1 / d3; d2 = d2 / d3; float f = this.size * (0.7F + this.world.rand.nextFloat() * 0.6F); // 爆炸的强度 double d4 = this.x; double d6 = this.y; double d8 = this.z; for (float f1 = 0.3F; f &gt; 0.0F; f -= 0.22500001F) &#123; // 强度的自然衰减 BlockPos blockpos = new BlockPos(d4, d6, d8); // 进行破坏判断的方块坐标 IBlockState iblockstate = this.world.getBlockState(blockpos); IFluidState ifluidstate = this.world.getFluidState(blockpos); if (!iblockstate.isAir() || !ifluidstate.isEmpty()) &#123; float f2 = Math.max(iblockstate.getBlock().getExplosionResistance(), ifluidstate.getExplosionResistance()); if (this.exploder != null) &#123; f2 = this.exploder.getExplosionResistance(this, this.world, blockpos, iblockstate, ifluidstate, f2); &#125; f -= (f2 + 0.3F) * 0.3F; //强度在破坏方块后的额外衰减 &#125; if (f &gt; 0.0F &amp;&amp; (this.exploder == null || this.exploder.canExplosionDestroyBlock(this, this.world, blockpos, iblockstate, f))) &#123; set.add(blockpos); // 方块被加入集合 &#125; d4 += d0 * (double)0.3F; // 步进 0.3 个单位向量 d6 += d1 * (double)0.3F; d8 += d2 * (double)0.3F; &#125; &#125; &#125; &#125; &#125; this.affectedBlockPositions.addAll(set); // 由集合产生便于遍历的列表 // 后面是实体相关代码，与方块无关&#125; 这是 doExplosionB() 中的代码： 点击展开代码 1234567891011public void doExplosionB(boolean spawnParticles) &#123; // 之前是声音和粒子部分代码，与方块无关 if (this.damagesTerrain) &#123; for (BlockPos blockpos : this.affectedBlockPositions) &#123; // 逐个破坏方块并产生粒子效果 &#125; &#125; // 之后是火焰相关代码，与方块无关&#125; 可以看到，在这一部分的代码中，为了防止多次破坏同一个位置的方块，采用了将方块先统一放进一个集合中，再统一处理的策略。因此，最终的顺序取决于 addAll(set) 方法产生的列表的顺序。为了弄清楚这一点，需要先观察集合的实现方法。 集合的的初始化是 Sets.&lt;BlockPos&gt;newHashSet() 这个静态方法本身返回一个使用默认构造器初始化的 java.util.HashSet，和 Set&lt;BlockPos&gt; set = new HashSet&lt;BlockPos&gt;(); 等价。由于 Java 中 HashSet 直接使用了哈希表，也就是内置了一个 HashMap&lt;HashSet,Object&gt; map，这里直接当作哈希表考虑。 哈希表是一个通过索引进行高速插入、查找和删除的数据结构。由于实际存在的对象数量过多，几乎不可能为每一个对象分配一个独一无二的索引值，因此每一个索引值都对应一个“哈希桶”（Hash Bucket），用于存放索引值相同的“相似”对象。 当 Minecraft 中的方块坐标，即 BlockPos 要存入哈希表，需要用它的三轴数值先计算出一个哈希值，也就是调用 hashCode()。产生的哈希值取决于三轴数值。在这之后，哈希值被用来调用 hash()，产生存放该坐标的哈希桶的索引值。由于哈希桶总数有限，需要把哈希值约束到一定范围内，因此最终被分配到哪个哈希桶还取决于哈希桶的总数。 为了保证哈希集各项操作的时间复杂度在 O(1)，需要保证元素总数（n）与哈希桶总数（m）之比低于一个固定值——装载因子（load factor，α），否侧过长的哈希桶会严重降低速度。元素过多时，Java 会重新设置哈希桶数组的大小（即哈希桶的总数），并将原有的元素再分配到这些新的哈希桶里。由于这里哈希集的初始化没有指定大小和装载因子，在 TNT 爆炸破坏方块的过程中，Java 会多次增加哈希桶，并重分配元素。 综上所述，爆炸破坏的顺序取决于 TNT 的破坏顺序，方块坐标以及 TNT 破坏方块的总数。在下一章中会对这些因素进行进一步的剖析，并且提出可行的解决方案。 ►解决方案 一个可行的方案是对玩家附近的活塞和 TNT 在客户端进行模拟计算，得出可能的信号源位置，并用客户端的渲染效果对玩家进行提示。 运算的结果会在世界的渲染函数中使用。这里借助 malilib，对 Minecraft 的 GameRenderer 类的 updateCameraAndRender() 方法进行注入。渲染时，首先要设置 OpenGL 的各项参数，并且将坐标变换玩家的视角。之后获取玩家周围一定范围内的所有方块，针对活塞方块调用之前的 getResults() 方法获得可以放置信号源的坐标，并根据权重设置颜色进行渲染。这部分代码不多阐述，具体可以在我的 Github 上看到[5]。 ►其它可行方案 在这里对另外两种可行方案进行简短介绍。两个都是由 Fallen_Breath 发现的。 其一是在同一游戏阶段激活两个 TNT，一个仅破坏红石块，另一个仅破坏活塞。这里用稳定的红石更新顺序所导致的多个 TNT 的先后爆炸顺序来替代不稳定的哈希表顺序，并且构造也比较简单。[6] 另一个方法是利用红石线达到多个信号源位置，并且只要其中一个最先被破坏，其余的就会熄灭，进而更新活塞。虽然这个方法依然存在一定的随机性，不能防止活塞先于所有红石线被破坏的情况，但对于彻底随机打乱了方块破坏顺序的 1.15 来说却是个不错的方法。[7] ►感谢 感谢 TIS Trinity Union 中的 Fallen_Breath 等人提供的修改意见。 ►参考资料 《Simple sidewards bedrock breaking method》作者： Myren Eario https://youtu.be/BL98BDMwyWM ↩ 《Simplest way to break Bedrock - Minecraft 1.13.1》作者：newcake https://youtu.be/Tu4C3QNBdRY ↩ 《[理论分析] 红石更新延迟理论》作者：Gamepiaynmo https://tieba.baidu.com/p/4078230299 ↩ 《深度剖析Minecraft #1 游戏流程》作者：Fallen_Breath https://www.bilibili.com/read/cv4122124 以及 https://forum.tis.world/topic/270/深度剖析minecraft-1-游戏流程 ↩ BedrockBreakHelper https://github.com/LucunJi/BedrockBreakHelper ↩ 《[1.10~1.15+] 100%成功率的铁头功破基岩法》作者：Fallen_Breath https://www.bilibili.com/video/av79942615 ↩ 作者：Fallen_Breath https://t.bilibili.com/333412049128925077 ↩","categories":[],"tags":[{"name":"minecraft","slug":"minecraft","permalink":"http://lucunji.github.io/tags/minecraft/"},{"name":"Java","slug":"Java","permalink":"http://lucunji.github.io/tags/Java/"}]},{"title":"极简风描图","slug":"minimalist-images","date":"2019-02-24T23:14:08.000Z","updated":"2020-01-04T09:49:00.770Z","comments":true,"path":"2019/02/24/minimalist-images/","link":"","permalink":"http://lucunji.github.io/2019/02/24/minimalist-images/","excerpt":"基本上就是PS用钢笔勾线然后涂色，分辨率很高。之前看到某位兄贵（不知道怎么称呼）的帖子 极简主义样式化的hsi，觉得很nb，自己也做了些图，就把图堆在这里吧。 ►","text":"基本上就是PS用钢笔勾线然后涂色，分辨率很高。之前看到某位兄贵（不知道怎么称呼）的帖子 极简主义样式化的hsi，觉得很nb，自己也做了些图，就把图堆在这里吧。 ► 《不吉波普不笑》的ED基本上都是这种极简的风格，自己挺喜欢的，于是就描了一张。 点此查看高清大图(76804320) | 白色背景版本(76804320) 原图： 《不吉波普不笑》给我的感觉挺惊艳的，Boogiepop 跟我在中二时期的人设挺像的： 能遮盖身体 95% 的长袍/披风/卫衣 √ 平时没事的时候当一个普通的中学生 √ 出场时恰到好处的笛声/口哨声 √ 很强并且能恰到好处又独到地处理事件 √ 反正挺喜欢的，就用来作头像吧","categories":[],"tags":[{"name":"anime images","slug":"anime-images","permalink":"http://lucunji.github.io/tags/anime-images/"}]},{"title":"Hexo 魔改指南","slug":"hexo-hacking-guide","date":"2018-12-14T03:12:50.000Z","updated":"2019-01-26T17:16:46.924Z","comments":true,"path":"2018/12/13/hexo-hacking-guide/","link":"","permalink":"http://lucunji.github.io/2018/12/13/hexo-hacking-guide/","excerpt":"这里说几个魔改 Hexo 博客的方法，顺便水一贴。遇到问题欢迎评论区留言。","text":"这里说几个魔改 Hexo 博客的方法，顺便水一贴。遇到问题欢迎评论区留言。 最新版NexT主题下载 最新版本 的 NexT 使用了一个不同于过往版本的 GitHub repo.。新版本的 NexT 在许多方面有着比旧版更方便的配置。安装时注意甄别。 字体设置 ►字体版权 注意版权问题！！ 有的字体商用需要购买版权，有的字体免费商用； 有的字体免费商用但是禁止嵌入软件、网页中； 有的字体禁止二次发布； 有的字体禁止修改名称和（或）修改内容后和（或）收取费用二次发布； ………… 以上每一条都可能单独成立。所以使用字体时记得看清楚发布源网页的信息、证书以及压缩包里附带的 readme（用户须知/使用声明） 文件。看说明书很重要！（由于外文字体一般都只有英文声明，所以学好英文是很重要的） 一般来说大公司都会等韭菜长大了再割 P.S.：我不太清楚重命名成英文会不会侵犯“禁止修改名称”这一条，所以就直接使用比较容易出编码问题的中文文件名了。 ►字体设置 声明和设置字体可以在 &lt;主题文件夹&gt;/source/css/_custom/custom.styl 这里设置 声明字体： 1234567@font-face &#123; font-family: /*字体系列名*/; src: url('../fonts/&lt;字体文件名&gt;'); /*你可以指定多个 url ，中间用逗号隔开。前一个字体使用失败时会自动尝试使用下一个。*/ /*就像这样： src: url('file1.ttf'), url('file2.svg');*/&#125; 使用字体： 123.site-title &#123; font-family: '&lt;字体系列名&gt;' !important;&#125; 字体文件就丢在 &lt;主题文件夹&gt;/source/css/fonts/ 在这个文件夹 ►字体的压缩 如果不禁止修改内容，那么直接把字体文件上传是很蠢的行为。如果是五十几 KB 的英文字体还好，一个中文字体能够有几 MB 的大小。这是极其浪费流量资源和加载时间的——实际用到的字形可能只是九牛一毛。 在这里极度推荐使用 字蛛（font-spider） 来对字体进行压缩。它的原理就是遍历相关的文件，记录每个字体文件的使用情况，然后创建只保留用到的字形的新字体文件。 安装过程我就不说了，请参照官网。下面讲几个坑点： 你应该对它输入 &lt;博客文件夹&gt;/public/index.html 记得打开 --debug， 否则出 Bug 以后它是不会报出来的 它对于 url 指定的路径的区分很蠢 相对路径记得用 ./（本层目录）和 ../（上层目录） base64 以及网络上的资源用 --map &quot;&lt;url 地址&gt;,&lt;本地地址&gt;&quot; 来映射到本地的字体文件 也可以在不需要处理的情况下把 @font-face{} 内容用 /*&lt;内容&gt;*/ 给注释掉 或者用 --ignore &quot;文件路径&quot; 来指定需要忽略掉的文件 反正我一个 4MB 的中英文字体文件给压成了 4KB，只保留 LucunJi 这些字符，效果很显著。 自定义页面 ►标签并入归档 标签、分类和归档单独分几个页面会导致类似的功能分散，特别是当自己的标签不多的时候。 具体操作是把 page.swig 里面的东西搬进 archive.swig。 把这些内容： 12345678910111213141516&lt;div class=&quot;post-block tag&quot;&gt; &lt;div class=&quot;tag-cloud&quot;&gt; &lt;div class=&quot;tag-cloud-title&quot;&gt; &#123;% set visibleTags = 0 %&#125; &#123;% for tag in site.tags %&#125; &#123;% if tag.length %&#125; &#123;% set visibleTags += 1 %&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;&#123; _p(&apos;counter.tag_cloud&apos;, visibleTags) &#125;&#125; &lt;/div&gt; &lt;div class=&quot;tag-cloud-tags&quot;&gt; &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 300, color: true, start_color: &apos;#ccc&apos;, end_color: &apos;#111&apos;&#125;) &#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 加入到这一行的后面。 1&#123;% block content %&#125; ►本地化 Hexo 博客可以进行本地化来方便不同语言的用户。 通过对作者代码的仿写，可以对自己新增的内容进行本地化。 语言文件都在 ./themes/&lt;主题&gt;/languages/ 这里，拿 zh-CN.yml 举例： 主题的 _config.yml 中的 12menu: archives: /archives/ || archive 里面， archives: 对应了 zh-CN.yml 的 12menu: archives: 归档 每个页面的标题，在 ./themes/next/layout/pages.swig 被给出，例如： 12#&#125;&#123;% elif page.type === &quot;tags&quot; and not page.title %&#125;&#123;# #&#125;&#123;&#123; __(&apos;title.tag&apos;) + page_title_suffix &#125;&#125;&#123;# 这里的 __('title.tag') 就对应了语言文件里的 12title: tag: 标签 往 md 里面塞 HTML 的神触操作 ►增加娱乐效果 ►鼠标悬停气泡 效果 代码: 12&lt;a title=\"气泡内容\"&gt;效果&lt;/a&gt;&lt;!-- 是的，追加href属性还能弄个超链接 --&gt; 一般人看不出来的 效果 代码: 1&lt;font title=\"气泡内容\"&gt;效果&lt;/font&gt; 你可以给几乎所有标签加入 title 属性，甚至包括图片： ►刮刮乐 示例：刮刮乐 因为每次都在 HTML 标签里面写 style太麻烦了，干脆写成 class 塞进 css 文件： 1234.scratch &#123; color:black; background-color:black;&#125; markdown 里面写这个 1&lt;font class=\"scratch\" title=\"刮开来试试OwO\"&gt;刮刮乐&lt;/font&gt; ►内嵌视频 批梨批梨之类傻批视频网站的内嵌代码是可以直接丢进 markdown 文件里面的，然而却不能自动缩放。 解决办法来自 肖运华个人网站 ，非常感谢。 &lt;iframe&gt; 标签外边套一层 &lt;div class=&quot;video&quot;&gt; 或者 &lt;p class=&quot;video&quot;&gt;，然后在之前说过的 custom.styl 里面加入如下样式代码： 123456789101112131415.video &#123; position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#125;.video iframe,.video object,.video embed &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#125; 保存，刷新，完事 记得 &lt;!-- more --&gt; 标签前面加上压缩过的视频封面而不是内嵌视频本体，否则还在预览部分流量就没了。 当然你在一页上丢太多视频可能会卡爆，并且吞噬大量的流量。 增加 QQ 好友分享 我分享系统用的是 needsharebutton2，配置起来很简单，官方文件应该就有，这里不再赘述。 要点在于加入“发送给QQ好友和群组”功能。如果用分享到QQ空间功能来替代这个的话会很麻烦的，更何况 TIM 用户一般很少看空间。 基本操作就是抄一下已有的代码，不过QQ好友分享必须要附带图片、标题 打开 &lt;博客目录&gt;\\themes\\next\\source\\lib\\needsharebutton\\needsharebutton.css， 在 1.icon-qqzone:before &#123; content: '\\f1d6'; &#125; 的下方添加 1.icon-qq:before &#123; content: '\\f1d6'; &#125; 并且把 12345678.need-share-button_qqzone &#123; color: #ffce00;&#125;.need-share-button_qqzone.need-share-button_link-box &#123; color: #fff; background: #ffce00;&#125; 复制一份，改成这样： 12345678.need-share-button_qq &#123; color: #00deff;&#125;.need-share-button_qq.need-share-button_link-box &#123; color: #fff; background: #41d0ff;/*天蓝色背景色，方便区分*/&#125; 这样 css 文件就配置好了，然后打开 &lt;博客目录&gt;\\themes\\next\\source\\lib\\needsharebutton\\needsharebutton.js 找到这一块代码： 123456789\"qqzone\": function (el) &#123; var myoptions = getOptions(el); var url = \"http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?title=\" + encodeURIComponent(myoptions.title) + \"&amp;url=\" + encodeURIComponent(myoptions.url) + \"&amp;pics=\" + encodeURIComponent(myoptions.image) + \"&amp;desc=\" + encodeURIComponent(myoptions.description); root.popup(url); &#125;, 在下面加入： 12345678910\"qq\": function (el) &#123; var myoptions = getOptions(el); var url = \"https://connect.qq.com/widget/shareqq/index.html?url=\" + encodeURIComponent(myoptions.url) + \"&amp;title=\" + encodeURIComponent(myoptions.title) + \"&amp;summary=\" + encodeURIComponent(myoptions.description) + \"&amp;pics=\" + \"&lt;你自己的博客头像之类的图片&gt;\"; //没有图片就不能分享了，所以强制指定一个图片比较稳 root.popup(url) &#125;, 然后找到这一行： 1networks: \"Weibo,Wechat,Douban,QQZone,Twitter,Pinterest,Facebook,GooglePlus,Reddit,Linkedin,Tumblr,Evernote\" 改成这个（加入 QQ 选项）： 1networks: \"Weibo,Wechat,Douban,QQZone,QQ,Twitter,Pinterest,Facebook,GooglePlus,Reddit,Linkedin,Tumblr,Evernote\" 最后修改此处,注意注释的地方: 123456789101112131415161718192021root.getDescription = function () &#123; var content; // check querySelector existance for old browsers if (document.querySelector) &#123; content = document.querySelector(\"meta[property=\\\"og:description\\\"]\") || document.querySelector(\"meta[name=\\\"twitter:description\\\"]\") || document.querySelector(\"meta[name=\\\"description\\\"]\"); if (content) &#123; return content.getAttribute(\"content\"); &#125; else &#123; return \"\";/*在双引号的里面添点东西,例如“我的博客”*/ &#125; &#125; else &#123; content = document.getElementsByTagName(\"meta\").namedItem(\"description\"); if (content) &#123; return content.getAttribute(\"content\"); &#125; else &#123; return \"LucunJi's blog\";/*同上一处注释*/ &#125; &#125; &#125;; 这样就魔改完毕了，在主题的 _config.yml 文件里添加上 qq： 1networks: Weibo,Wechat,Douban,QQZone,QQ,Twitter,Facebook 最终效果如下： LeanCloud安全漏洞 如果你用 LeanCloud 统计阅读数，记得看看这里。 对了，最后的 deploy 应该写成这样: 12345deploy: - type: git repo: #你的 repository branch: master - type: leancloud_counter_security_sync 不在 type 前面加短划线会报错。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://lucunji.github.io/tags/Hexo/"},{"name":"NexT","slug":"NexT","permalink":"http://lucunji.github.io/tags/NexT/"}]},{"title":"3Ws","slug":"3Ws","date":"2018-12-11T23:35:19.000Z","updated":"2020-07-12T08:56:52.902Z","comments":true,"path":"2018/12/11/3Ws/","link":"","permalink":"http://lucunji.github.io/2018/12/11/3Ws/","excerpt":"►你好，欢迎来到这里： 3Ws, 即英文里的三个“W”：为什么（Why），哪里（Where），谁（Who）。 在这里，我将回答建立这里的原因，我，以及这篇博客。","text":"►你好，欢迎来到这里： 3Ws, 即英文里的三个“W”：为什么（Why），哪里（Where），谁（Who）。 在这里，我将回答建立这里的原因，我，以及这篇博客。 Why: 这里的建立 网络审查。 由于反复的网站审核，每一个网络用户的言行都受到了夸张的限制。用户可以因为如下原因被删除言论，禁言，甚至短期或永久封号： 不可说； 发布对于网站利益相关人不利的言论，包括但不限于高层人员、签约盈利用户以及拥有大量资本的其它人员； 被他人举报，理由任意； 进行网站运营方无法获得利润的商业活动； 拒绝网站的实名认证、客户端授权等获取用户隐私的行为； 发布链接或上传资源，导致被误认为发布广告； 异地登陆，高速发言，图文直播等异常行为； …………………… 除此之外的原因还有对于其它网站环境和功能的不满，一直想找个地方搭建伪春菜的愿望（无限拖延中）以及其它的一些影响。 Where: 这个博客 首先感谢以 TDsimon 博客为主的许许多多简单易懂的教程，我这篇博客的很多设置都是照抄他的。 架设在 GitHub 上的博客，具体信息可以看网页的最底端↓↓↓ 排版参照 中文文案排版指北。 Hexo 官方的 HelloWorld 文件，出于对作者的感谢，没有删除。 评论区没有初始化或者有bug的话麻烦b站私信，谢谢合作。 书单和相册正准备搞。 反正出 bug 可以交 issue，但是不保证会修复。 Who: 关于我 生卒年月（YYYY/MM/DD）：2000/11/29 - 不详。 性别：IRL, 男。 掌握技能： 初级的 PS, PR 使用； SolidWorks 入门级使用，不包括仿真、曲线模型等技能； 英文翻译 + 打轴； 初级拉丁语，词汇和语法较少； 初级 Java 水平，缺乏对工程的掌控力，正在学习。 身份/角色： Minecraft 模组\\红石玩家； CFPA 模组汉化组成员； TIS Trinity Union 服务器成员； 模组教程独立搬运工 + 翻译；（现已停止活动） 亚文化的游牧民族。 人设什么的 naidesu，就算有的话也会很迷吧。不想把自己用标签框住。 知识水平并不丰富，身体素质较弱。需要多读书多锻炼。 喜欢的二次元角色——应该没有，不过《艾尔之光》的妮莎和《Serial Experiments Lain》里的铃音可以算吧。游戏技术也比较菜，属于那种什么都只会一点的。 由于对自己的执行力有着充分的不信任，目前倾向于自己一个人开坑填坑以及弃坑。 目前（2019 年 9 月 - ）大学本科就读，业余精力不多。 于2018年12月建立了这个博客。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-02-07T03:09:23.368Z","updated":"2018-12-12T12:53:49.824Z","comments":true,"path":"2018/02/06/hello-world/","link":"","permalink":"http://lucunji.github.io/2018/02/06/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. ►Quick Start ►Create a new post 1$ hexo new \"My New Post\" More info: Writing ►Run server 1$ hexo server More info: Server ►Generate static files 1$ hexo generate More info: Generating ►Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}