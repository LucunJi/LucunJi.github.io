{"meta":{"title":"LucunJi","subtitle":null,"description":null,"author":"LucunJi","url":"http://lucunji.github.io"},"pages":[{"title":"Booklist","date":"2018-12-12T23:39:00.000Z","updated":"2019-12-22T10:04:54.035Z","comments":true,"path":"booklist/index.html","permalink":"http://lucunji.github.io/booklist/index.html","excerpt":"","text":"⚠ 施=====工=====中 ⚠ ►虽然魔茶那边已经有了个大书库，但我还是在这里做一些分享，希望能帮助更多的人。"},{"title":"Gallery","date":"2018-12-13T00:12:26.000Z","updated":"2018-12-21T02:43:11.783Z","comments":true,"path":"gallery/index.html","permalink":"http://lucunji.github.io/gallery/index.html","excerpt":"","text":"⚠ 施=====工=====中 ⚠"},{"title":"All Tags","date":"2018-12-12T20:39:03.000Z","updated":"2018-12-21T02:42:46.657Z","comments":false,"path":"tags/index.html","permalink":"http://lucunji.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"电梯","slug":"elevator","date":"2020-07-12T08:22:17.000Z","updated":"2020-07-12T09:05:46.609Z","comments":true,"path":"2020/07/12/elevator/","link":"","permalink":"http://lucunji.github.io/2020/07/12/elevator/","excerpt":"没人能准确说出这台玻璃电梯前往的最高层是第几层。电梯井数倍高于商厦本身，而凭空高出商厦的那部分自然没有任何中间楼层。也就是说，从十几层到最终的几十层之间没有任何的停靠点。 上升不可撤销，下降亦然。","text":"没人能准确说出这台玻璃电梯前往的最高层是第几层。电梯井数倍高于商厦本身，而凭空高出商厦的那部分自然没有任何中间楼层。也就是说，从十几层到最终的几十层之间没有任何的停靠点。 上升不可撤销，下降亦然。 全玻璃构造的轿厢在玻璃电梯井内被一根明显不够粗的缆绳悬着。缆绳刚好连着轿厢顶部的正中心。若是轿厢没人，它可以以轻微摇晃的态势有惊无险地保持平衡。 这种设计的本意应该是让乘客在上升过程中饱览城市风景。可惜轿厢的地板也是玻璃的，再加上这摇摇欲坠的结构，很难想象乘客还能有心情去浏览风景。 这座城市也没有什么风景。建筑都是式样较老，稀稀拉拉的。商厦——更确切地说是这个电梯井——算是附近唯一的高楼。而天空每天基本上都是凄惨的白色，佐以不多不少，刚好让人可以偷懒不带口罩的雾霾。 这栋大厦不仅有这一部电梯。边上的另一部电梯的式样是在小区商场中随处可见的全金属结构，可惜它只在较低的楼层徘徊，并不通向几十层的高空。 电梯的顶部确实存在着一个楼层，那是仅靠着电梯井悬在半空的真正意义上的空中楼阁。原本那里是废弃的，但最近有人在上面办了一个英语补习班。这座城市中一部分有着勉勉强强，还算殷实的家底的学生，让这座电梯开始忙碌起来。 那个办补习班的人，想必是个万里挑一的优秀教师？并非如此，只是这座小城并无其他在英语水平上勉强称得上出众的人。边上的S城固然有不错的教育资源，可S城的生活开销太大，与小城之间也隔了几个小时的路途。也没有多少人称那个年轻人为某老师。家长们叫他小某，学生们则直呼姓名。 电梯上去又下来了。电梯门打开的时候里面是空的，因此大致可以推断之前进入的那位成功登顶了。既然之前的人平安无事，那这一次应该也是安全的。不过如果上升到一半出了故障，后果是可想而知的。 但在玻璃的移门在身后关上后，手不假思索地按下了最上面的那个按钮。 电梯开始不紧不慢地上升。上升到一半的时候，由人导致的重心偏移使轿厢开始在电梯井里打旋。渐渐地，人开始用后背贴着玻璃壁，站也站不稳了。想在电梯里惊呼，但电梯里并没有其他人去听。两个人的重量对于这部电梯来说太过勉强了。又约莫过了半分钟，电梯终于到达顶端。晃动的轿厢和外面的地板间有三四十公分的空隙，但人终究还是迈过去了。 这样的光景，每天要重复上下两遍，每个月总共有大约十次。并没有谁看到工人来维修过电梯，仿佛电梯对于这些学生以外的其它人来说是不存在的。电梯这么运行了将近半年，有过好几次在半空中卡住，又恢复过来继续运行的奇迹，从来没出过人命。至于办补习班的那位年轻人是怎么上去的，似乎没有多少人思考过。 在数十米的高空乘坐如此摇摇欲坠的电梯，这似乎严重有悖于生命的本能。然而比起从数十米高空跌下来的后果，似乎有更加抽象而恐怖的东西在逼迫着这些灵长目动物。 后记 这篇文章来源于做过的梦。后来添加上一些别的东西，就作成了这篇文章。写的时候尝试把字数尽量压缩，但居然也写出了一千字。这篇文章的一个更为完整的标题可以是《电梯-小城与那群妄想逃离的学生》。这篇文章可以算是魔幻现实。艺术来源于生活，但是麻烦不要对号入座，qqqxx（3q谢谢） 这篇文章的隐喻我觉得不难看出来。如果要我多说一点的话是这样的：这部电梯虽然有来有回，但是整个小城以及更大的环境使得这部电梯和它隐喻的一些东西变成了真正意义上的单行道。 另外，这篇文章是以我的主观感受写的，如果有不同的想法，很正常，说，都可以说。","categories":[],"tags":[{"name":"misc","slug":"misc","permalink":"http://lucunji.github.io/tags/misc/"}]},{"title":"关于 Minecraft 社区规范","slug":"on-minecraft-community-custom","date":"2020-04-18T11:11:58.000Z","updated":"2020-04-18T14:35:48.454Z","comments":true,"path":"2020/04/18/on-minecraft-community-custom/","link":"","permalink":"http://lucunji.github.io/2020/04/18/on-minecraft-community-custom/","excerpt":"目前的 Minecraft 社区中，一直存在着关于红石、建筑、指令各领域用户作品归属、使用、再创作等问题的争论。这些争议短则一天，长则一周甚至一月。这些争议很少能够被较为圆满地解决，而由这些争议所引发的社区中的进步就更是凤毛麟角。","text":"目前的 Minecraft 社区中，一直存在着关于红石、建筑、指令各领域用户作品归属、使用、再创作等问题的争论。这些争议短则一天，长则一周甚至一月。这些争议很少能够被较为圆满地解决，而由这些争议所引发的社区中的进步就更是凤毛麟角。 了解一些英文的读者可以看出，这篇文章的标题是 On Minecraft Community Custom，致敬了大作家蒙田的文章 On Custom。作为一次东施效颦，在这篇文章里我会尝试着以怀疑态度对一些 MC 社区中的观点进行反驳。此文仅代表我在写作此文时的态度——我的观点必然会随着时间或多或少地变化。另外，我也期待与各位读者进行相关话题的探讨。 为了讨论对 MC 玩家作品的使用和借鉴规范，我们回到问题的根本处。之所以需要此类探讨，是因为现存的法律体系难以给出一个令人满意的答案。将视野拉远，互联网的版权问题一直存在着争议：迪士尼层出不穷的版权官司，漫画本地化人员的冷遇，“搬运工”涉及到的种种争议。互联网上作品传播、保存、评论的简单快捷注定使得非互联网领域的版权规范在这里显得古板而笨拙。于是各个网络社区的用户都尝试着在表达创作的同时自行约定规范。经过较长一段时间的积淀后，这些零散的规范逐渐变得深入人心，由此便形成了各种社区规范习俗。MMD[1]会要求制作者注明“借物表”，即列出所使用的模型的作者；不去“本家”（即原作）刷翻唱也称成为音乐相关作品的礼仪规范。 然而，并不是所有用户社区都可以在这样的一个过程中形成一套自己的规范，Minecraft 社区就是一个例子。可以做出如下分析：由于入门 Minecraft 游戏并没有太大的难度，玩家并不会刻意地加入专门讨论这个游戏的社区。他们可以只是用这个游戏打发业余时间，与朋友联络。而另一些事物，例如 音MAD[2]，MMD 等，都对用户有着较高的入门要求。因此用户更倾向于加入一个专一的社区来更高效地提升水平。由于 Minecraft 用户完全可以游离于专门的社区之外，很难确保他们对于社区的规范有所了解。另外，Minecraft 服务器使得玩家更倾向于分散为更小的群体，各自为政。这些小群体内部往往有着比外部社区更高的交流。这些小群体之间并非没有交流，但是往往较难暴露出观点的一些差异。 这些关于作品所有权、使用方法的意见差异，往往会导致群体之间的争论，并且在这些争论中被暴露出来。不过由于缺乏有组织的、理性的思考，这些争论往往并不会产生什么真正有利社区的结果——休战只是为了双方止损，而观念的差异却没有被解决。持有不同意见的个人、群体之间难以建立有效的对话。观点的交流往往被妥协所取代。 在这些争论中，一种常见的观点是对现存版权法律的“拿来主义”。持有这种观念的人通常会使用现存法律条文中的规定来画出网络上侵权与非侵权的界线，并据此认为，应有的裁定已经完成，剩下的只是依照现有条文进行处罚。然而，在经过考虑以后，人们应该会发现这种思维只是图一时之方便的偷懒之举。这种观点错误地判断了原因与结果：因现有法律条文难以较好地适配网络社区，而需要对此乱象进行更细致的讨论；并非因现存的种种乱象，需要引用现存的法律条文来进行规范。如果现存的法律条文能较好地对网络社区进行规范，各种争执便不会产生。而目前出现的争论，正是现有条文无法维持社区秩序的印证。 于是，问题从来没有从根本上解决，因为这种生搬硬套往往难以让人信服。正如福熙对于第一次世界大战的评论[3]： This is not peace. It is an armistice for 20 years. 这不是和平。这是二十年的休战。 这种“拿来主义”是一种因恐惧争论进一步激化而不愿深入探讨问题的消极作风。不仅不能提供一种有效的解决手段，反而会使这个社区的成员产生一种“有法可依”的错觉。一旦类似争议再次爆发，用户便会出现一种奇妙的心理状态。他们对于被怀疑侵权者产生了一种犹如敌视罪犯一般的道德谴责，同时又对假定的秩序无法被有效遵守产生一种沮丧、悲观态度。于是常常会出现对被怀疑者的激烈声讨，与对社区整体的不信任。为了不使文章离题，这里不对常见的有罪推定、非黑即白等进一步激化矛盾的误区进行赘述，不过作为题外话，小心地求证，并大胆假设正方反方意见应当位列行为准则之中。 基于个人对目前 MC 社区的微不足道的观察，一种有效地改良方式应当是这样的：首先应当积极地推动不同小群体、不同小领域之间的对话。不仅要在争论的时候进行探讨，更要在平时进行探讨。在一时的争论中，对话双方可能会因为利益、公众影响等原因有所顾忌、有所保留；而在平时，双方一般会有较少的顾虑，也更容易心平气和地进行探讨。另外，不能完全摒弃现存法律的条文，而是有所选择性的利用。现存的条文通常是基于一定的假设和原则而制定的。当我们将这些条文搬到网络环境中时，需要考虑到他们所基于的假设是否在 Minecraft 社区中存在，是否在网络社区中产生了变化。这里的逻辑类似于知乎上的一段关于马克思主义的论述[4]： ……历史上并非先有了一套“不拥有生产资料”，“代表先进生产力”，“领导阶级”的论断之后，才有人去研究资本主义社会的弊病，经济剥削的本质，革命力量的所在。真正的逻辑是倒过来的，有了对社会现实的大量研究，对社会革命的强烈动机，为此结合实践创建了一整套理论体系，最后才有人去抽象出几个论断，方便人理解。 例如，创作者可以通过 Creative Commons 等协议注明自己保留、转让、放弃的权利。而具体到如何界定抄袭和侵权，可以由作者明确划出规范，也可以商量决定。海外 Minecraft 社区关于这一点上采取的措施可能可以起到不错的示范作用。 以上便是我对 Minecraft 社区中用户版权的一些思考。希望能为社区的良性发展起到贡献。 [1] 即 MikuMikuDance https://zh.moegirl.org/MikuMikuDance [2] 为日文音系MAD／音声MAD的缩略语，是一种使用素材中的乐器对所选BGM进行演奏的视频形式 https://zh.moegirl.org/音MAD# [3] Ruth Henig, Versailles and After, 1919-33 (Routledge, 1995), p. 52. [4] 作者：白头豕 链接：https://www.zhihu.com/question/36851145/answer/108617648 来源：知乎","categories":[],"tags":[{"name":"minecraft","slug":"minecraft","permalink":"http://lucunji.github.io/tags/minecraft/"}]},{"title":"简易修改 Minecraft 字节码","slug":"minecraft-bytecode-modding","date":"2020-01-16T08:13:34.000Z","updated":"2020-02-21T03:21:21.133Z","comments":true,"path":"2020/01/16/minecraft-bytecode-modding/","link":"","permalink":"http://lucunji.github.io/2020/01/16/minecraft-bytecode-modding/","excerpt":"100% vanilla!","text":"100% vanilla! ►简介 之前看到 1.15.2-pre1 更新了玩家种植树木也会刷新蜂巢的特性，研究完机制以后想着修改一下蜂巢刷新几率来方便测试。 可是这时候 fabric 啥的还没更新，于是想到了之前 EDDExample 说过的修改字节码大法。顺便用上 Mojang 1.14.4 以来的官方反混淆表。 EDDExample 在视频里用的是 JByteMod 来修改字节码。可以在 https://github.com/GraxCode/JByteMod-Beta/releases 下载到。 ►反混淆 前往 https://github.com/hube12/DecompilerMC/releases ，在 Releases for lazy users 下面下载适合操作系统的版本，这里就选择 Windows.zip。 将压缩包解压，会看到有一个 McDecompiler.exe 文件，运行后根据提示选择，依次输入 y，cfr，1.15.2-pre1 以及 y。 等待几分钟，程序运行完毕后就可以在 src 文件夹里看到反混淆好的源码；在 mappings 里看到反混淆表。 ►查找修改目标 通过在反混淆的源码中搜索，可以找到负责在树上生成蜂巢的装饰器 net.minecraft.world.level.levelgen.feature.treedecorators.BeehiveDecorator 这里通过产生一个随机的单精度浮点数，实现了蜂巢生成概率的随机化： 12345public void place(LevelAccessor var1, Random var2, List var3, List var4, Set var5, BoundingBox var6) &#123; if (var2.nextFloat() &lt; this.probability) &#123; //... &#125;&#125; 由于 Minecraft 中的类名、方法名是经过混淆的，我们无法直接查看字节码。在反混淆表中搜索类名 BeehiveDecorator，会发现它的混淆后的类名是 ciq，方法 place 混淆后的名称是 a。值得注意的是，一个混淆的类会包含多个同名但不同参数的方法，因此需要额外留心方法的参数数量和类型。 ►修改字节码 用解压软件打开版本文件 1.15.2-pre1.jar，单独拖出 ciq.class 文件，用 JByteMod 打开这个类文件，开始修改。 之前我试过直接打开整个 jar，结果修改后无法正常启动游戏。后来折腾了半天才发现单独拖出来修改类文件就好了。 首先定位到要修改的方法。之前找到的方法拥有6个参数，其中第2、3、4、5个参数的类型分别是 Random，List，List 以及 Set（Java 自带的类型一般不会被反混淆）。点开这个方法，发现开头的几行字节码分别是： 12345678910aload 2invokevirtual float Random.nextFloat()aload 0getfield float ciq.bfcmpliflt 2label 1returnlabel 2...... 通过翻阅 JVM 指令集，可以得知这几行指令的效果： 加载下标为 2，即类型为 Random 的传入参数的引用； 调用该对象的 nextFloat() 方法，返回一个 float； 加载下标为 0 的传入参数，即 this 的引用； 获取该对象的成员变量，对象属于类 ciq，对象名是 b，变量类型是 float； 比较 (2) (3) 两处的 float 值； 如果 (3) 处小于 (2) 处，跳转到标签 2 处执行剩余指令，否则继续往下执行 return 退出方法。 这几行描述的内容和反编译出来的 if (var2.nextFloat() &lt; this.probability) {} 对应。没问题，接着进行下一步。把前两行删去，替换成 ldc Float 0.0 就可以变成每次尝试必定成功的 if (0.0f &lt; this.probability) {}。 删除前两行 -&gt; 右键点击 getfield -&gt; 插入之前 -&gt; LdcInsnNode -&gt; 类型选择 Float，值输入 0.0。 完成后保存类文件，准备替换。 ►核心 jar 替换法 核心 jar 替换法，顾名思义就是直接替换 versions 文件夹中核心版本文件 1.15.2-pre1.jar 的类。为了防止游戏对 jar 进行完整性检测，需要删除 jar 中的 META-INF 文件夹，并且删除 1.15.2-pre1.json 中的下载链接。具体链接内容因版本而异，并且注意逗号： 1\"downloads\": &#123;\"client\": &#123;\"sha1\": \"9f28455f9f9d09294e0ba19beb13dc26b39a9582\", \"size\": 15531212, \"url\": \"https://launcher.mojang.com/v1/objects/9f28455f9f9d09294e0ba19beb13dc26b39a9582/client.jar\"&#125;, \"client_mappings\": &#123;\"sha1\": \"6c81c6f2e6ff0c3a2795f5d336c63b0740a60a45\", \"size\": 4971880, \"url\": \"https://launcher.mojang.com/v1/objects/6c81c6f2e6ff0c3a2795f5d336c63b0740a60a45/client.txt\"&#125;, \"server\": &#123;\"sha1\": \"5db50a719dc40d63aa95c6bdc5b302e425f673f2\", \"size\": 36175423, \"url\": \"https://launcher.mojang.com/v1/objects/5db50a719dc40d63aa95c6bdc5b302e425f673f2/server.jar\"&#125;, \"server_mappings\": &#123;\"sha1\": \"f59bfc0ebb62bc7802af0567ad79592274c56943\", \"size\": 3737013, \"url\": \"https://launcher.mojang.com/v1/objects/f59bfc0ebb62bc7802af0567ad79592274c56943/server.txt\"&#125;&#125;, ►运行 如果一切操作都没有问题，那么游戏将能够正常的启动。 创建一个新的世界，在花的边上种下一棵白桦树或橡树，必定会产生一个蜂巢。 ►MultiMC 配置方法 MultiMC 提供了方便的 Jar mod 安装方式。只要删除 META-INF 文件夹，就可以在 Edit Instance 中选择 Add to Minecraft.jar 或者 Replace Minecraft.jar，选择修改后的 jar 载入就可以了。 需要注意的是，再次修改 jar 过后，需要在列表中移除并重新加入修改后的 jar。 ►感谢 EDDxample，他在 YouTube 上有不错的关于代码和模组制作的视频 https://youtu.be/T_658BztqVE ，使用 JByteMod 的点子也是从这个视频里学到的。","categories":[],"tags":[{"name":"minecraft","slug":"minecraft","permalink":"http://lucunji.github.io/tags/minecraft/"},{"name":"Java","slug":"Java","permalink":"http://lucunji.github.io/tags/Java/"},{"name":"bytecode","slug":"bytecode","permalink":"http://lucunji.github.io/tags/bytecode/"}]},{"title":"附带 Mixin 的 Rift 开发环境配置方法","slug":"rift-with-mixin-setup","date":"2020-01-04T06:02:24.000Z","updated":"2020-07-12T08:26:11.345Z","comments":true,"path":"2020/01/04/rift-with-mixin-setup/","link":"","permalink":"http://lucunji.github.io/2020/01/04/rift-with-mixin-setup/","excerpt":"2020/2/20 更新：懒人用开发环境 https://github.com/LucunJi/Rift-MDK-with-Mixin 在 1.13.2 的 Minecraft 版本下，许多的模组并不依赖 Forge 或者 Fabric，而是 Rift。然而目前 1.13.2 现存的 MDK（Mod Develop Kit，模组开发包） 并不包含 Mixin。但是 Rift 提供的监听接口较少，很多功能都需要开发者自己利用 Mixin 来对原版代码（准确的说是字节码）进行修改。这里分享一下如何配置一个包含 Mixin 的 Rift 开发环境，帮有类似需求的人节约时间。","text":"2020/2/20 更新：懒人用开发环境 https://github.com/LucunJi/Rift-MDK-with-Mixin 在 1.13.2 的 Minecraft 版本下，许多的模组并不依赖 Forge 或者 Fabric，而是 Rift。然而目前 1.13.2 现存的 MDK（Mod Develop Kit，模组开发包） 并不包含 Mixin。但是 Rift 提供的监听接口较少，很多功能都需要开发者自己利用 Mixin 来对原版代码（准确的说是字节码）进行修改。这里分享一下如何配置一个包含 Mixin 的 Rift 开发环境，帮有类似需求的人节约时间。 ►基础环境配置 首先到 https://github.com/DimensionalDevelopment/Rift-MDK/tree/1.13.2 下载不包含 Rift 的 MDK 到本地。这时候文件结构看起来应该是这样的： 12345678910111213141516171819202122D:\\RIFT-MDK-1.13.2│ .gitattributes│ .gitignore│ build.gradle│ gradlew│ gradlew.bat│ README.md│├─gradle│ └─wrapper│ gradle-wrapper.jar│ gradle-wrapper.properties│└─src └─main ├─java │ └─example │ ExampleListener.java │ └─resources pack.mcmeta riftmod.json 这里使用 Intellij IDEA 为例子，选择 build.gradle 进行导入。导入完毕之后直接打开右侧 Gradle 面板，双击 setupDecompWorkspace 进行基本环境的配置。由于需要反编译并反混淆，可能会花上几分钟。等到显示 BUILD SUCCESSFUL，环境就搭建完毕了。 在这一步可能会遇到提示 Cannot find hunk target。这时候运行 cleanCache 清空缓存，然后重新运行 setupDecompWorkspace 就好。 接下来尝试启动 Minecraft。这里不能直接运行 runClient，应该运行 External Librarries（外部库）里的 start/net.minecraftforge.gradle/GradleStart，在 Program arguments 中填入 --tweakClass org.dimdev.riftloader.launch.RiftLoaderClientTweaker，并将 Use classpath of module 设置成 Rift-MDK-1.13.2.main。之后点击 Run，就可以运行 Minecraft 了。如果只运行服务端，那么可以把上面的 Program arguments 中的 Client 改成 Server。 ►配置 Mixin[1] ►修改 Gradle 配置文件 首先打开根目录下的 build.gradle，在末尾（或者按你的喜好排版）添加 Mixin 的插件、配置信息、仓库地址和依赖项： 123456789101112131415apply plugin: 'org.spongepowered.mixin'mixin &#123; defaultObfuscationEnv notch add sourceSets.main, 'mixins.example.refmap.json'&#125;buildscript &#123; repositories &#123; maven &#123; url 'http://repo.spongepowered.org/maven' &#125; &#125; dependencies &#123; classpath 'org.spongepowered:mixingradle:0.6-SNAPSHOT' &#125;&#125; 此时点击 Gradle 窗口左上角的循环标志（Reimport All Gradle Projects），应该会重新配置开发环境，出现 CONFIGURE SUCCESSFUL 说明配置成功。 ►Mixin 配置文件 在 src/main/java/resources 文件夹下创建 mixins.example.json，内容如下： 1234567891011121314&#123; \"required\": true, \"minVersion\": \"0.7.11\", \"compatibilityLevel\": \"JAVA_8\", \"target\": \"@env(DEFAULT)\", \"package\": \"example.mixin\", \"refmap\": \"mixins.example.refmap.json\", \"mixins\": [ ], \"client\": [ ], \"server\": [ ]&#125; ►初始化 Mixin Mixin 需要在 Minecraft 的类被加载前被启动。先在 src/main/java/example 包内创建类 ModInitializationListener 实现接口 InitializationListener。并且在实现的方法 onInitialization 中初始化 Mixin 并且加载配置文件 。全部代码如下： 12345678910111213package example;import org.dimdev.riftloader.listener.InitializationListener;import org.spongepowered.asm.launch.MixinBootstrap;import org.spongepowered.asm.mixin.Mixins;public class ModInitializationListener implements InitializationListener &#123; @Override public void onInitialization() &#123; MixinBootstrap.init(); Mixins.addConfiguration(\"mixins.example.json\"); &#125;&#125; 同时修改 riftmod.json，告知 Rift 加载器新增的事件监听器。修改后内容如下： 1234567891011&#123; \"id\": \"example\", \"name\": \"Example\", \"authors\": [ \"\" ], \"listeners\": [ \"example.ExampleListener\", \"example.ModInitializationListener\" ]&#125; 至此，Mixin 就配置完毕了。 ►试运行 首先创建包 example.mixin，并新建类 MixinLoadingGui，输入如下代码： 12345678910111213141516171819package example.mixin;import net.minecraft.client.Minecraft;import net.minecraft.client.audio.SimpleSound;import net.minecraft.client.gui.GuiScreenLoading;import net.minecraft.init.SoundEvents;import org.spongepowered.asm.mixin.Mixin;import org.spongepowered.asm.mixin.injection.At;import org.spongepowered.asm.mixin.injection.Inject;import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;@Mixin(GuiScreenLoading.class)public class MixinLoadingGui &#123; @Inject(method = \"onGuiClosed\", at = @At(\"RETURN\")) private void onRender(CallbackInfo ci) &#123; Minecraft.getInstance().getSoundHandler().play(SimpleSound.music(SoundEvents.ENTITY_GENERIC_EXPLODE)); &#125;&#125; 并且在 mixins.example.json 的 client 列表中添加这个类的类名（不用包名，因为已经指定好了），添加完后是这样的： 123456789101112131415&#123; \"required\": true, \"minVersion\": \"0.7.11\", \"compatibilityLevel\": \"JAVA_8\", \"target\": \"@env(DEFAULT)\", \"package\": \"example.mixin\", \"refmap\": \"mixins.example.refmap.json\", \"mixins\": [ ], \"client\": [ \"MixinLoadingGui\" ], \"server\": [ ]&#125; 接着启动游戏。如果一切没有问题，在游戏加载完毕后会听到一声爆炸 “轰！” ►拓展阅读 Mixin 官方文档：https://github.com/SpongePowered/Mixin/wiki 官方文档中文翻译：https://mouse0w0.github.io/2018/11/07/Introduction-to-Mixins-Overwriting-Methods/ 国内的教程 CoreModTutor：https://xfl03.gitbook.io/coremodtutor/5/5.1 ►参考资料 Rift-ModList 作者：shedaniel https://github.com/shedaniel/Rift-ModList ↩","categories":[],"tags":[]},{"title":"浅谈活塞破基岩法的不稳定性起源及解决方法","slug":"bedrock-breaking","date":"2020-01-02T22:28:59.000Z","updated":"2020-01-07T20:41:32.789Z","comments":true,"path":"2020/01/02/bedrock-breaking/","link":"","permalink":"http://lucunji.github.io/2020/01/02/bedrock-breaking/","excerpt":"本文针对最早由 Myren Eario 提出的利用活塞移除基岩的方法所存在的不稳定性进行分析，并提出一种可行的解决方案。","text":"本文针对最早由 Myren Eario 提出的利用活塞移除基岩的方法所存在的不稳定性进行分析，并提出一种可行的解决方案。 ►原方法简介 基岩在 Minecraft 无法被生存模式下的玩家通过挖掘的方式破坏。但是由于高效刷怪塔、凋灵相关设施、地狱交通等需求，玩家有时需要移除基岩来完成某个工程。于是，陆续有玩家发现了 Minecraft 程序中的漏洞，并开发出了一些移除基岩的方法。 最早在 2016年5月3日，Myren Eario 在 YouTube 上发布了一个利用活塞和 TNT 移除基岩的方案[1]。不过由于这个方案存在随机性，并且当时还有稳定性更高的弱加载区块龙蛋移除法，该方案并没有受到较大的关注。但在 1.13 修复了龙蛋相关的漏洞之后，玩家只能利用活塞来移除基岩。本文中提到的这个方法的应用开始变得广泛了。 ►复现过程 如上图所示，使用该方法需要一个伸出的活塞（粘性或普通的均可）和一个 TNT（图中白色的即为点燃的 TNT 实体）。玩家需要不断尝试按下右键，在源活塞底座的位置放置一个朝向基岩的活塞。如果不使用辅助放置的模组的话，这里需要一个不会被爆炸破坏的方块（如黑曜石）作为放置的参照物。 在保证右键点击的频率足够高的前提下有几率会将原先被活塞背对的基岩移除，并留下一个活塞方块。 这个方法的变体可以在其它的视频中看到。例如：活塞可以朝上放置以从上往下移除地狱上方的基岩层。[2]在右侧红石块上放置 TNT 后，装备鞘翅的玩家快速双击空格缩小碰撞体积，钻入楼梯下方（在 1.14 以及之后的版本中可以用活板门下压法替代） 之后对着黑曜石离自己最近的上棱角快速点击右键，就可以达到和 Myren 的方法相似的效果，移除基岩。 ►方法原理 根据游戏事件顺序[3]可以得出以下事件顺序： TNT 爆炸： TNT 实体在 Entity Update 阶段引发爆炸，破坏活塞底座、活塞臂和信号源。 若信号源先于活塞底座或活塞臂被破坏，活塞接收到方块更新，并计划在下一次的 Block Event 开始收回动作。接着活塞被破坏，掉落； 若活塞底座或活塞臂其一先于信号源被破坏，则活塞整体会被破坏并掉落，不会在下一次 Block Event 进行动作； 活塞在被破坏后不撤回 Block Event 中的计划。 玩家放置： 在 Network Update 阶段（这里采用另一篇文章[4]的习惯，将玩家更新相关的阶段合二为一），服务器处理发出放置活塞的数据。由于该位置原有活塞已被摧毁，活塞被成功放置并面朝基岩。 移除基岩： 如果在 1 中的信号源被最先破坏，那么下一 gt 的 Block Event 中，会在原有活塞的位置进行收回动作。由于游戏在这时 不检测活塞朝向，会根据新放置的活塞进行从下往上的收回。由于游戏尝试把不存在的活塞臂从基岩的位置抽回，基岩被替换成了空气方块。新放下的活塞本身变成了一个 36号方块。 剩余步骤： 剩余步骤为：36号方块在经过 3 个 Tile Entity Update 之后变为一个与最初的活塞朝向一致的收回的活塞。 以上便是活塞移除基岩的事件顺序。不难看出成功的关键在于步骤 1 中爆炸破坏方块的顺序，以及 2 中玩家是否能及时发送尝试放置方块的数据包。最后一步完全由稳定的游戏机制保障运行，无须担心。 步骤 2 可以由一个稳定的外部连点器软件，或者一个快速点击的模组保证，于是唯一难以解决的问题出现在步骤 1 上，而这也是一般人所知的不稳定性的来源。 另外，由于有时基岩无法移除是因为玩家在 2 中放置的活塞朝向并不与原有活塞相反，这里提出一个判断玩家操作是否正确的方法。观察 4 中最后产生的活塞，如果朝向与最初活塞相反，那么可以认为操作无误。否则可能是操作不当。 ►不稳定性起因 在实际操作过程中不难发现：装置、操作方法一致，但在不同的位置会产生不同的效果。有点位置能够移除基岩，而有的则不能。而且即使位置相同，TNT的摆放位置不同，结果也不同。 举个例子，在 1.13.2 中的 x=48, y=1, z=-6 位置放置一个向上的活塞，它的北侧放置黑曜石，南侧放置红石块，采用上文提及的 newcake 的方法。当 TNT 被放置在红石块上引爆时，无法移除活塞正下方的基岩；而当 TNT 被放置在伸出的活塞臂上引爆时，可以移除基岩。 根据上一章节的分析，在排除玩家操作失误的因素后，唯一的问题在于爆炸破坏方块的先后顺序。因此这一章对爆炸部分的游戏源码进行阅读、分析，旨在找出不稳定性在 Minecraft 中的起因。 这里的源代码来自 1.13.2 Rift 模组开发环境自带的 Minecraft Coder Pack。爆炸相关的 Java 类是 net.minecraft.world.Explosion，主要法方法有两个：doExplosionA() 统计所有需要被破坏的方块，并伤害实体；doExplosionB() 破坏统计的方块，产生方块掉落物并显示粒子效果。 首先是 doExplosionA() 中的代码： 点击展开代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public void doExplosionA() &#123; Set&lt;BlockPos&gt; set = Sets.&lt;BlockPos&gt;newHashSet(); // 与 Set&lt;BlockPos&gt; set = new HashSet&lt;BlockPos&gt;(); 等价 int i = 16; for (int j = 0; j &lt; 16; ++j) &#123; for (int k = 0; k &lt; 16; ++k) &#123; for (int l = 0; l &lt; 16; ++l) &#123; if (j == 0 || j == 15 || k == 0 || k == 15 || l == 0 || l == 15) &#123; // 产生爆炸射线 double d0 = (double)((float)j / 15.0F * 2.0F - 1.0F); double d1 = (double)((float)k / 15.0F * 2.0F - 1.0F); double d2 = (double)((float)l / 15.0F * 2.0F - 1.0F); double d3 = Math.sqrt(d0 * d0 + d1 * d1 + d2 * d2); d0 = d0 / d3; // 计算成单位向量 d1 = d1 / d3; d2 = d2 / d3; float f = this.size * (0.7F + this.world.rand.nextFloat() * 0.6F); // 爆炸的强度 double d4 = this.x; double d6 = this.y; double d8 = this.z; for (float f1 = 0.3F; f &gt; 0.0F; f -= 0.22500001F) &#123; // 强度的自然衰减 BlockPos blockpos = new BlockPos(d4, d6, d8); // 进行破坏判断的方块坐标 IBlockState iblockstate = this.world.getBlockState(blockpos); IFluidState ifluidstate = this.world.getFluidState(blockpos); if (!iblockstate.isAir() || !ifluidstate.isEmpty()) &#123; float f2 = Math.max(iblockstate.getBlock().getExplosionResistance(), ifluidstate.getExplosionResistance()); if (this.exploder != null) &#123; f2 = this.exploder.getExplosionResistance(this, this.world, blockpos, iblockstate, ifluidstate, f2); &#125; f -= (f2 + 0.3F) * 0.3F; //强度在破坏方块后的额外衰减 &#125; if (f &gt; 0.0F &amp;&amp; (this.exploder == null || this.exploder.canExplosionDestroyBlock(this, this.world, blockpos, iblockstate, f))) &#123; set.add(blockpos); // 方块被加入集合 &#125; d4 += d0 * (double)0.3F; // 步进 0.3 个单位向量 d6 += d1 * (double)0.3F; d8 += d2 * (double)0.3F; &#125; &#125; &#125; &#125; &#125; this.affectedBlockPositions.addAll(set); // 由集合产生便于遍历的列表 // 后面是实体相关代码，与方块无关&#125; 这是 doExplosionB() 中的代码： 点击展开代码 1234567891011public void doExplosionB(boolean spawnParticles) &#123; // 之前是声音和粒子部分代码，与方块无关 if (this.damagesTerrain) &#123; for (BlockPos blockpos : this.affectedBlockPositions) &#123; // 逐个破坏方块并产生粒子效果 &#125; &#125; // 之后是火焰相关代码，与方块无关&#125; 可以看到，在这一部分的代码中，为了防止多次破坏同一个位置的方块，采用了将方块先统一放进一个集合中，再统一处理的策略。因此，最终的顺序取决于 addAll(set) 方法产生的列表的顺序。为了弄清楚这一点，需要先观察集合的实现方法。 集合的的初始化是 Sets.&lt;BlockPos&gt;newHashSet() 这个静态方法本身返回一个使用默认构造器初始化的 java.util.HashSet，和 Set&lt;BlockPos&gt; set = new HashSet&lt;BlockPos&gt;(); 等价。由于 Java 中 HashSet 直接使用了哈希表，也就是内置了一个 HashMap&lt;HashSet,Object&gt; map，这里直接当作哈希表考虑。 哈希表是一个通过索引进行高速插入、查找和删除的数据结构。由于实际存在的对象数量过多，几乎不可能为每一个对象分配一个独一无二的索引值，因此每一个索引值都对应一个“哈希桶”（Hash Bucket），用于存放索引值相同的“相似”对象。 当 Minecraft 中的方块坐标，即 BlockPos 要存入哈希表，需要用它的三轴数值先计算出一个哈希值，也就是调用 hashCode()。产生的哈希值取决于三轴数值。在这之后，哈希值被用来调用 hash()，产生存放该坐标的哈希桶的索引值。由于哈希桶总数有限，需要把哈希值约束到一定范围内，因此最终被分配到哪个哈希桶还取决于哈希桶的总数。 为了保证哈希集各项操作的时间复杂度在 O(1)，需要保证元素总数（n）与哈希桶总数（m）之比低于一个固定值——装载因子（load factor，α），否侧过长的哈希桶会严重降低速度。元素过多时，Java 会重新设置哈希桶数组的大小（即哈希桶的总数），并将原有的元素再分配到这些新的哈希桶里。由于这里哈希集的初始化没有指定大小和装载因子，在 TNT 爆炸破坏方块的过程中，Java 会多次增加哈希桶，并重分配元素。 综上所述，爆炸破坏的顺序取决于 TNT 的破坏顺序，方块坐标以及 TNT 破坏方块的总数。在下一章中会对这些因素进行进一步的剖析，并且提出可行的解决方案。 ►解决方案 一个可行的方案是对玩家附近的活塞和 TNT 在客户端进行模拟计算，得出可能的信号源位置，并用客户端的渲染效果对玩家进行提示。 运算的结果会在世界的渲染函数中使用。这里借助 malilib，对 Minecraft 的 GameRenderer 类的 updateCameraAndRender() 方法进行注入。渲染时，首先要设置 OpenGL 的各项参数，并且将坐标变换玩家的视角。之后获取玩家周围一定范围内的所有方块，针对活塞方块调用之前的 getResults() 方法获得可以放置信号源的坐标，并根据权重设置颜色进行渲染。这部分代码不多阐述，具体可以在我的 Github 上看到[5]。 ►其它可行方案 在这里对另外两种可行方案进行简短介绍。两个都是由 Fallen_Breath 发现的。 其一是在同一游戏阶段激活两个 TNT，一个仅破坏红石块，另一个仅破坏活塞。这里用稳定的红石更新顺序所导致的多个 TNT 的先后爆炸顺序来替代不稳定的哈希表顺序，并且构造也比较简单。[6] 另一个方法是利用红石线达到多个信号源位置，并且只要其中一个最先被破坏，其余的就会熄灭，进而更新活塞。虽然这个方法依然存在一定的随机性，不能防止活塞先于所有红石线被破坏的情况，但对于彻底随机打乱了方块破坏顺序的 1.15 来说却是个不错的方法。[7] ►感谢 感谢 TIS Trinity Union 中的 Fallen_Breath 等人提供的修改意见。 ►参考资料 《Simple sidewards bedrock breaking method》作者： Myren Eario https://youtu.be/BL98BDMwyWM ↩ 《Simplest way to break Bedrock - Minecraft 1.13.1》作者：newcake https://youtu.be/Tu4C3QNBdRY ↩ 《[理论分析] 红石更新延迟理论》作者：Gamepiaynmo https://tieba.baidu.com/p/4078230299 ↩ 《深度剖析Minecraft #1 游戏流程》作者：Fallen_Breath https://www.bilibili.com/read/cv4122124 以及 https://forum.tis.world/topic/270/深度剖析minecraft-1-游戏流程 ↩ BedrockBreakHelper https://github.com/LucunJi/BedrockBreakHelper ↩ 《[1.10~1.15+] 100%成功率的铁头功破基岩法》作者：Fallen_Breath https://www.bilibili.com/video/av79942615 ↩ 作者：Fallen_Breath https://t.bilibili.com/333412049128925077 ↩","categories":[],"tags":[{"name":"minecraft","slug":"minecraft","permalink":"http://lucunji.github.io/tags/minecraft/"},{"name":"Java","slug":"Java","permalink":"http://lucunji.github.io/tags/Java/"}]},{"title":"极简风描图","slug":"minimalist-images","date":"2019-02-24T23:14:08.000Z","updated":"2020-01-04T09:49:00.770Z","comments":true,"path":"2019/02/24/minimalist-images/","link":"","permalink":"http://lucunji.github.io/2019/02/24/minimalist-images/","excerpt":"基本上就是PS用钢笔勾线然后涂色，分辨率很高。之前看到某位兄贵（不知道怎么称呼）的帖子 极简主义样式化的hsi，觉得很nb，自己也做了些图，就把图堆在这里吧。 ►","text":"基本上就是PS用钢笔勾线然后涂色，分辨率很高。之前看到某位兄贵（不知道怎么称呼）的帖子 极简主义样式化的hsi，觉得很nb，自己也做了些图，就把图堆在这里吧。 ► 《不吉波普不笑》的ED基本上都是这种极简的风格，自己挺喜欢的，于是就描了一张。 点此查看高清大图(76804320) | 白色背景版本(76804320) 原图： 《不吉波普不笑》给我的感觉挺惊艳的，Boogiepop 跟我在中二时期的人设挺像的： 能遮盖身体 95% 的长袍/披风/卫衣 √ 平时没事的时候当一个普通的中学生 √ 出场时恰到好处的笛声/口哨声 √ 很强并且能恰到好处又独到地处理事件 √ 反正挺喜欢的，就用来作头像吧","categories":[],"tags":[{"name":"anime images","slug":"anime-images","permalink":"http://lucunji.github.io/tags/anime-images/"}]},{"title":"Hexo 魔改指南","slug":"hexo-hacking-guide","date":"2018-12-14T03:12:50.000Z","updated":"2019-01-26T17:16:46.924Z","comments":true,"path":"2018/12/13/hexo-hacking-guide/","link":"","permalink":"http://lucunji.github.io/2018/12/13/hexo-hacking-guide/","excerpt":"这里说几个魔改 Hexo 博客的方法，顺便水一贴。遇到问题欢迎评论区留言。","text":"这里说几个魔改 Hexo 博客的方法，顺便水一贴。遇到问题欢迎评论区留言。 最新版NexT主题下载 最新版本 的 NexT 使用了一个不同于过往版本的 GitHub repo.。新版本的 NexT 在许多方面有着比旧版更方便的配置。安装时注意甄别。 字体设置 ►字体版权 注意版权问题！！ 有的字体商用需要购买版权，有的字体免费商用； 有的字体免费商用但是禁止嵌入软件、网页中； 有的字体禁止二次发布； 有的字体禁止修改名称和（或）修改内容后和（或）收取费用二次发布； ………… 以上每一条都可能单独成立。所以使用字体时记得看清楚发布源网页的信息、证书以及压缩包里附带的 readme（用户须知/使用声明） 文件。看说明书很重要！（由于外文字体一般都只有英文声明，所以学好英文是很重要的） 一般来说大公司都会等韭菜长大了再割 P.S.：我不太清楚重命名成英文会不会侵犯“禁止修改名称”这一条，所以就直接使用比较容易出编码问题的中文文件名了。 ►字体设置 声明和设置字体可以在 &lt;主题文件夹&gt;/source/css/_custom/custom.styl 这里设置 声明字体： 1234567@font-face &#123; font-family: /*字体系列名*/; src: url('../fonts/&lt;字体文件名&gt;'); /*你可以指定多个 url ，中间用逗号隔开。前一个字体使用失败时会自动尝试使用下一个。*/ /*就像这样： src: url('file1.ttf'), url('file2.svg');*/&#125; 使用字体： 123.site-title &#123; font-family: '&lt;字体系列名&gt;' !important;&#125; 字体文件就丢在 &lt;主题文件夹&gt;/source/css/fonts/ 在这个文件夹 ►字体的压缩 如果不禁止修改内容，那么直接把字体文件上传是很蠢的行为。如果是五十几 KB 的英文字体还好，一个中文字体能够有几 MB 的大小。这是极其浪费流量资源和加载时间的——实际用到的字形可能只是九牛一毛。 在这里极度推荐使用 字蛛（font-spider） 来对字体进行压缩。它的原理就是遍历相关的文件，记录每个字体文件的使用情况，然后创建只保留用到的字形的新字体文件。 安装过程我就不说了，请参照官网。下面讲几个坑点： 你应该对它输入 &lt;博客文件夹&gt;/public/index.html 记得打开 --debug， 否则出 Bug 以后它是不会报出来的 它对于 url 指定的路径的区分很蠢 相对路径记得用 ./（本层目录）和 ../（上层目录） base64 以及网络上的资源用 --map &quot;&lt;url 地址&gt;,&lt;本地地址&gt;&quot; 来映射到本地的字体文件 也可以在不需要处理的情况下把 @font-face{} 内容用 /*&lt;内容&gt;*/ 给注释掉 或者用 --ignore &quot;文件路径&quot; 来指定需要忽略掉的文件 反正我一个 4MB 的中英文字体文件给压成了 4KB，只保留 LucunJi 这些字符，效果很显著。 自定义页面 ►标签并入归档 标签、分类和归档单独分几个页面会导致类似的功能分散，特别是当自己的标签不多的时候。 具体操作是把 page.swig 里面的东西搬进 archive.swig。 把这些内容： 12345678910111213141516&lt;div class=&quot;post-block tag&quot;&gt; &lt;div class=&quot;tag-cloud&quot;&gt; &lt;div class=&quot;tag-cloud-title&quot;&gt; &#123;% set visibleTags = 0 %&#125; &#123;% for tag in site.tags %&#125; &#123;% if tag.length %&#125; &#123;% set visibleTags += 1 %&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;&#123; _p(&apos;counter.tag_cloud&apos;, visibleTags) &#125;&#125; &lt;/div&gt; &lt;div class=&quot;tag-cloud-tags&quot;&gt; &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 300, color: true, start_color: &apos;#ccc&apos;, end_color: &apos;#111&apos;&#125;) &#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 加入到这一行的后面。 1&#123;% block content %&#125; ►本地化 Hexo 博客可以进行本地化来方便不同语言的用户。 通过对作者代码的仿写，可以对自己新增的内容进行本地化。 语言文件都在 ./themes/&lt;主题&gt;/languages/ 这里，拿 zh-CN.yml 举例： 主题的 _config.yml 中的 12menu: archives: /archives/ || archive 里面， archives: 对应了 zh-CN.yml 的 12menu: archives: 归档 每个页面的标题，在 ./themes/next/layout/pages.swig 被给出，例如： 12#&#125;&#123;% elif page.type === &quot;tags&quot; and not page.title %&#125;&#123;# #&#125;&#123;&#123; __(&apos;title.tag&apos;) + page_title_suffix &#125;&#125;&#123;# 这里的 __('title.tag') 就对应了语言文件里的 12title: tag: 标签 往 md 里面塞 HTML 的神触操作 ►增加娱乐效果 ►鼠标悬停气泡 效果 代码: 12&lt;a title=\"气泡内容\"&gt;效果&lt;/a&gt;&lt;!-- 是的，追加href属性还能弄个超链接 --&gt; 一般人看不出来的 效果 代码: 1&lt;font title=\"气泡内容\"&gt;效果&lt;/font&gt; 你可以给几乎所有标签加入 title 属性，甚至包括图片： ►刮刮乐 示例：刮刮乐 因为每次都在 HTML 标签里面写 style太麻烦了，干脆写成 class 塞进 css 文件： 1234.scratch &#123; color:black; background-color:black;&#125; markdown 里面写这个 1&lt;font class=\"scratch\" title=\"刮开来试试OwO\"&gt;刮刮乐&lt;/font&gt; ►内嵌视频 批梨批梨之类傻批视频网站的内嵌代码是可以直接丢进 markdown 文件里面的，然而却不能自动缩放。 解决办法来自 肖运华个人网站 ，非常感谢。 &lt;iframe&gt; 标签外边套一层 &lt;div class=&quot;video&quot;&gt; 或者 &lt;p class=&quot;video&quot;&gt;，然后在之前说过的 custom.styl 里面加入如下样式代码： 123456789101112131415.video &#123; position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#125;.video iframe,.video object,.video embed &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#125; 保存，刷新，完事 记得 &lt;!-- more --&gt; 标签前面加上压缩过的视频封面而不是内嵌视频本体，否则还在预览部分流量就没了。 当然你在一页上丢太多视频可能会卡爆，并且吞噬大量的流量。 增加 QQ 好友分享 我分享系统用的是 needsharebutton2，配置起来很简单，官方文件应该就有，这里不再赘述。 要点在于加入“发送给QQ好友和群组”功能。如果用分享到QQ空间功能来替代这个的话会很麻烦的，更何况 TIM 用户一般很少看空间。 基本操作就是抄一下已有的代码，不过QQ好友分享必须要附带图片、标题 打开 &lt;博客目录&gt;\\themes\\next\\source\\lib\\needsharebutton\\needsharebutton.css， 在 1.icon-qqzone:before &#123; content: '\\f1d6'; &#125; 的下方添加 1.icon-qq:before &#123; content: '\\f1d6'; &#125; 并且把 12345678.need-share-button_qqzone &#123; color: #ffce00;&#125;.need-share-button_qqzone.need-share-button_link-box &#123; color: #fff; background: #ffce00;&#125; 复制一份，改成这样： 12345678.need-share-button_qq &#123; color: #00deff;&#125;.need-share-button_qq.need-share-button_link-box &#123; color: #fff; background: #41d0ff;/*天蓝色背景色，方便区分*/&#125; 这样 css 文件就配置好了，然后打开 &lt;博客目录&gt;\\themes\\next\\source\\lib\\needsharebutton\\needsharebutton.js 找到这一块代码： 123456789\"qqzone\": function (el) &#123; var myoptions = getOptions(el); var url = \"http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?title=\" + encodeURIComponent(myoptions.title) + \"&amp;url=\" + encodeURIComponent(myoptions.url) + \"&amp;pics=\" + encodeURIComponent(myoptions.image) + \"&amp;desc=\" + encodeURIComponent(myoptions.description); root.popup(url); &#125;, 在下面加入： 12345678910\"qq\": function (el) &#123; var myoptions = getOptions(el); var url = \"https://connect.qq.com/widget/shareqq/index.html?url=\" + encodeURIComponent(myoptions.url) + \"&amp;title=\" + encodeURIComponent(myoptions.title) + \"&amp;summary=\" + encodeURIComponent(myoptions.description) + \"&amp;pics=\" + \"&lt;你自己的博客头像之类的图片&gt;\"; //没有图片就不能分享了，所以强制指定一个图片比较稳 root.popup(url) &#125;, 然后找到这一行： 1networks: \"Weibo,Wechat,Douban,QQZone,Twitter,Pinterest,Facebook,GooglePlus,Reddit,Linkedin,Tumblr,Evernote\" 改成这个（加入 QQ 选项）： 1networks: \"Weibo,Wechat,Douban,QQZone,QQ,Twitter,Pinterest,Facebook,GooglePlus,Reddit,Linkedin,Tumblr,Evernote\" 最后修改此处,注意注释的地方: 123456789101112131415161718192021root.getDescription = function () &#123; var content; // check querySelector existance for old browsers if (document.querySelector) &#123; content = document.querySelector(\"meta[property=\\\"og:description\\\"]\") || document.querySelector(\"meta[name=\\\"twitter:description\\\"]\") || document.querySelector(\"meta[name=\\\"description\\\"]\"); if (content) &#123; return content.getAttribute(\"content\"); &#125; else &#123; return \"\";/*在双引号的里面添点东西,例如“我的博客”*/ &#125; &#125; else &#123; content = document.getElementsByTagName(\"meta\").namedItem(\"description\"); if (content) &#123; return content.getAttribute(\"content\"); &#125; else &#123; return \"LucunJi's blog\";/*同上一处注释*/ &#125; &#125; &#125;; 这样就魔改完毕了，在主题的 _config.yml 文件里添加上 qq： 1networks: Weibo,Wechat,Douban,QQZone,QQ,Twitter,Facebook 最终效果如下： LeanCloud安全漏洞 如果你用 LeanCloud 统计阅读数，记得看看这里。 对了，最后的 deploy 应该写成这样: 12345deploy: - type: git repo: #你的 repository branch: master - type: leancloud_counter_security_sync 不在 type 前面加短划线会报错。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://lucunji.github.io/tags/Hexo/"},{"name":"NexT","slug":"NexT","permalink":"http://lucunji.github.io/tags/NexT/"}]},{"title":"3Ws","slug":"3Ws","date":"2018-12-11T23:35:19.000Z","updated":"2020-07-12T08:56:52.902Z","comments":true,"path":"2018/12/11/3Ws/","link":"","permalink":"http://lucunji.github.io/2018/12/11/3Ws/","excerpt":"►你好，欢迎来到这里： 3Ws, 即英文里的三个“W”：为什么（Why），哪里（Where），谁（Who）。 在这里，我将回答建立这里的原因，我，以及这篇博客。","text":"►你好，欢迎来到这里： 3Ws, 即英文里的三个“W”：为什么（Why），哪里（Where），谁（Who）。 在这里，我将回答建立这里的原因，我，以及这篇博客。 Why: 这里的建立 网络审查。 由于反复的网站审核，每一个网络用户的言行都受到了夸张的限制。用户可以因为如下原因被删除言论，禁言，甚至短期或永久封号： 不可说； 发布对于网站利益相关人不利的言论，包括但不限于高层人员、签约盈利用户以及拥有大量资本的其它人员； 被他人举报，理由任意； 进行网站运营方无法获得利润的商业活动； 拒绝网站的实名认证、客户端授权等获取用户隐私的行为； 发布链接或上传资源，导致被误认为发布广告； 异地登陆，高速发言，图文直播等异常行为； …………………… 除此之外的原因还有对于其它网站环境和功能的不满，一直想找个地方搭建伪春菜的愿望（无限拖延中）以及其它的一些影响。 Where: 这个博客 首先感谢以 TDsimon 博客为主的许许多多简单易懂的教程，我这篇博客的很多设置都是照抄他的。 架设在 GitHub 上的博客，具体信息可以看网页的最底端↓↓↓ 排版参照 中文文案排版指北。 Hexo 官方的 HelloWorld 文件，出于对作者的感谢，没有删除。 评论区没有初始化或者有bug的话麻烦b站私信，谢谢合作。 书单和相册正准备搞。 反正出 bug 可以交 issue，但是不保证会修复。 Who: 关于我 生卒年月（YYYY/MM/DD）：2000/11/29 - 不详。 性别：IRL, 男。 掌握技能： 初级的 PS, PR 使用； SolidWorks 入门级使用，不包括仿真、曲线模型等技能； 英文翻译 + 打轴； 初级拉丁语，词汇和语法较少； 初级 Java 水平，缺乏对工程的掌控力，正在学习。 身份/角色： Minecraft 模组\\红石玩家； CFPA 模组汉化组成员； TIS Trinity Union 服务器成员； 模组教程独立搬运工 + 翻译；（现已停止活动） 亚文化的游牧民族。 人设什么的 naidesu，就算有的话也会很迷吧。不想把自己用标签框住。 知识水平并不丰富，身体素质较弱。需要多读书多锻炼。 喜欢的二次元角色——应该没有，不过《艾尔之光》的妮莎和《Serial Experiments Lain》里的铃音可以算吧。游戏技术也比较菜，属于那种什么都只会一点的。 由于对自己的执行力有着充分的不信任，目前倾向于自己一个人开坑填坑以及弃坑。 目前（2019 年 9 月 - ）大学本科就读，业余精力不多。 于2018年12月建立了这个博客。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-02-07T03:09:23.368Z","updated":"2018-12-12T12:53:49.824Z","comments":true,"path":"2018/02/06/hello-world/","link":"","permalink":"http://lucunji.github.io/2018/02/06/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. ►Quick Start ►Create a new post 1$ hexo new \"My New Post\" More info: Writing ►Run server 1$ hexo server More info: Server ►Generate static files 1$ hexo generate More info: Generating ►Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}